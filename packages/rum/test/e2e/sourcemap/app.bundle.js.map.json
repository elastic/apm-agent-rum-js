{
  "version": 3,
  "sources": [
    "webpack:///webpack/bootstrap 66667ffd7e2d4a9c9dd2",
    "webpack:///./dist/bundles/elastic-apm-js-base.umd.js",
    "webpack:///./test/e2e/general-usecase/app.js",
    "webpack:///./test/e2e/e2e.js",
    "webpack:///../apm-agent-js-core/test/utils/apm-server-mock.js",
    "webpack:///../apm-agent-js-core/src/common/subscription.js"
  ],
  "names": [],
  "mappings": ";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;;AAGA,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,0BAA0B,aAAa;AAChG,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB;;;AAGnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;;AAED,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA,2DAA2D,UAAU;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,iFAAiF,6BAA6B;AAC9G;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,2DAA2D,2BAA2B;;AAEtF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;;AAEP,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,mHAAmH;AACnH;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,6BAA6B;AAChE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE;AACvE;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,aAAa;AACb,+EAA+E,6BAA6B;AAC5G;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,uCAAuC;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,oFAAoF,qCAAqC;AACzH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,8FAA8F;AAC9F,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,OAAO;AACP;AACA;;AAEA;AACA,8CAA8C;;AAE9C,oGAAoG,mBAAmB,EAAE,mBAAmB,8HAA8H;;AAE1Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oIAAoI;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6JAA6J;AAC7J;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gIAAgI,wBAAwB,oCAAoC;AAC5L,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,sEAAsE;AAC3J;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oDAAoD;AAClG;AACA,iBAAiB;AACjB;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,yEAAyE,gBAAgB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iBAAiB;AAChF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8BAA8B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,0BAA0B,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+FAA+F;AAC/F;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,gBAAgB;AACzF;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,6CAA6C,0CAA0C;AACvF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0CAA0C;AAChH;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,4BAA4B;;AAE5B,OAAO;AACP;AACA;;AAEA;;;AAGA,gCAAgC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEjjB,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA,CAAC,E;;;;;;ACtoMD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA,2BAA2B,sEAAsE;AACjG,6BAA6B,2BAA2B;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtDA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA",
  "file": "app.e2e-bundle.js",
  "sourcesContent": [
    " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 66667ffd7e2d4a9c9dd2",
    "(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"elastic-apm-js-base\"] = factory();\n\telse\n\t\troot[\"elastic-apm-js-base\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar slice = [].slice;\n\nfunction isCORSSupported() {\n  var xhr = new window.XMLHttpRequest();\n  return 'withCredentials' in xhr;\n}\n\nfunction isPlatformSupported() {\n  return typeof window !== 'undefined' && typeof Array.prototype.forEach === 'function' && typeof JSON.stringify === 'function' && typeof Function.bind === 'function' && window.performance && typeof window.performance.now === 'function' && isCORSSupported();\n}\n\nmodule.exports = {\n  getViewPortInfo: function getViewPort() {\n    var e = document.documentElement;\n    var g = document.getElementsByTagName('body')[0];\n    var x = window.innerWidth || e.clientWidth || g.clientWidth;\n    var y = window.innerHeight || e.clientHeight || g.clientHeight;\n\n    return {\n      width: x,\n      height: y\n    };\n  },\n\n  mergeObject: function mergeObject(o1, o2) {\n    var a;\n    var o3 = {};\n\n    for (a in o1) {\n      o3[a] = o1[a];\n    }\n\n    for (a in o2) {\n      o3[a] = o2[a];\n    }\n\n    return o3;\n  },\n\n  extend: function extend(dst) {\n    return this.baseExtend(dst, slice.call(arguments, 1), false);\n  },\n\n  merge: function merge(dst) {\n    return this.baseExtend(dst, slice.call(arguments, 1), true);\n  },\n\n  baseExtend: function baseExtend(dst, objs, deep) {\n    for (var i = 0, ii = objs.length; i < ii; ++i) {\n      var obj = objs[i];\n      if (!isObject(obj) && !isFunction(obj)) continue;\n      var keys = Object.keys(obj);\n      for (var j = 0, jj = keys.length; j < jj; j++) {\n        var key = keys[j];\n        var src = obj[key];\n\n        if (deep && isObject(src)) {\n          if (!isObject(dst[key])) dst[key] = Array.isArray(src) ? [] : {};\n          baseExtend(dst[key], [src], false); // only one level of deep merge\n        } else {\n          dst[key] = src;\n        }\n      }\n    }\n\n    return dst;\n  },\n\n  isObject: isObject,\n\n  isFunction: isFunction,\n\n  arrayReduce: function arrayReduce(arrayValue, callback, value) {\n    // Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\n    if (arrayValue == null) {\n      throw new TypeError('Array.prototype.reduce called on null or undefined');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback + ' is not a function');\n    }\n    var t = Object(arrayValue);\n    var len = t.length >>> 0;\n    var k = 0;\n\n    if (!value) {\n      while (k < len && !(k in t)) {\n        k++;\n      }\n      if (k >= len) {\n        throw new TypeError('Reduce of empty array with no initial value');\n      }\n      value = t[k++];\n    }\n\n    for (; k < len; k++) {\n      if (k in t) {\n        value = callback(value, t[k], k, t);\n      }\n    }\n    return value;\n  },\n\n  arraySome: function arraySome(value, callback, thisArg) {\n    // Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some\n    if (value == null) {\n      throw new TypeError('Array.prototype.some called on null or undefined');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError();\n    }\n\n    var t = Object(value);\n    var len = t.length >>> 0;\n\n    if (!thisArg) {\n      thisArg = void 0;\n    }\n\n    for (var i = 0; i < len; i++) {\n      if (i in t && callback.call(thisArg, t[i], i, t)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  arrayMap: function arrayMap(arrayValue, callback, thisArg) {\n    // Source https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Map\n    var T, A, k;\n\n    if (this == null) {\n      throw new TypeError(' this is null or not defined');\n    }\n    var O = Object(arrayValue);\n    var len = O.length >>> 0;\n\n    if (typeof callback !== 'function') {\n      throw new TypeError(callback + ' is not a function');\n    }\n    if (arguments.length > 1) {\n      T = thisArg;\n    }\n    A = new Array(len);\n    k = 0;\n    while (k < len) {\n      var kValue, mappedValue;\n      if (k in O) {\n        kValue = O[k];\n        mappedValue = callback.call(T, kValue, k, O);\n        A[k] = mappedValue;\n      }\n      k++;\n    }\n    return A;\n  },\n\n  arrayIndexOf: function arrayIndexOf(arrayVal, searchElement, fromIndex) {\n    // Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf\n    var k;\n    if (arrayVal == null) {\n      throw new TypeError('\"arrayVal\" is null or not defined');\n    }\n\n    var o = Object(arrayVal);\n    var len = o.length >>> 0;\n\n    if (len === 0) {\n      return -1;\n    }\n\n    var n = +fromIndex || 0;\n\n    if (Math.abs(n) === Infinity) {\n      n = 0;\n    }\n\n    if (n >= len) {\n      return -1;\n    }\n\n    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n    while (k < len) {\n      if (k in o && o[k] === searchElement) {\n        return k;\n      }\n      k++;\n    }\n    return -1;\n  },\n\n  functionBind: function functionBind(func, oThis) {\n    // Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\n    var aArgs = Array.prototype.slice.call(arguments, 2);\n    var FNOP = function FNOP() {};\n    var fBound = function fBound() {\n      return func.apply(oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n    };\n\n    FNOP.prototype = func.prototype;\n    fBound.prototype = new FNOP();\n    return fBound;\n  },\n\n  getRandomInt: function getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  },\n\n  isUndefined: function isUndefined(obj) {\n    return typeof obj === 'undefined';\n  },\n\n  isCORSSupported: isCORSSupported,\n  getElasticScript: function getElasticScript() {\n    if (typeof document !== 'undefined') {\n      var scripts = document.getElementsByTagName('script');\n      for (var i = 0, l = scripts.length; i < l; i++) {\n        var sc = scripts[i];\n        if (sc.src.indexOf('elastic') > 0) {\n          return sc;\n        }\n      }\n    }\n  },\n\n  getCurrentScript: function getCurrentScript() {\n    if (typeof document !== 'undefined') {\n      // Source http://www.2ality.com/2014/05/current-script.html\n      var currentScript = document.currentScript;\n      if (!currentScript) {\n        return this.getElasticScript();\n      }\n      return currentScript;\n    }\n  },\n\n  generateUuid: function generateUuid() {\n    function _p8(s) {\n      var p = (Math.random().toString(16) + '000000000').substr(2, 8);\n      return s ? '-' + p.substr(0, 4) + '-' + p.substr(4, 4) : p;\n    }\n    return _p8() + _p8(true) + _p8(true) + _p8();\n  },\n\n  parseUrl: function parseUrl(url) {\n    // source: angular.js/$LocationProvider\n    var PATH_MATCH = /^([^\\?#]*)(\\?([^#]*))?(#(.*))?$/;\n    var match = PATH_MATCH.exec(url);\n    var path = match[1] || '';\n    var queryString = match[3] || '';\n    var hash = match[5] ? '#' + match[5] : '';\n\n    var protocol = '';\n    if (url.indexOf('://') > -1) {\n      protocol = url.split('://')[0] + ':';\n    }\n\n    var params = {};\n    var queries = queryString.split('&');\n    for (var i = 0, l = queries.length; i < l; i++) {\n      var query = queries[i];\n      if (query === '' || typeof query === 'undefined' || query === null) {\n        continue;\n      }\n      var keyvalue = queries[i].split('=');\n      var key = keyvalue.shift();\n      params[key] = keyvalue.join('=');\n    }\n    return { protocol: protocol, path: path, queryString: queryString, queryStringParsed: params, hash: hash };\n  },\n\n  isPlatformSupported: isPlatformSupported\n};\n\nfunction isObject(value) {\n  // http://jsperf.com/isobject4\n  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Subscription() {\n  this.subscriptions = [];\n}\n\nSubscription.prototype.subscribe = function (fn) {\n  var self = this;\n  this.subscriptions.push(fn);\n\n  return function () {\n    var index = self.subscriptions.indexOf(fn);\n    if (index > -1) {\n      self.subscriptions.splice(index, 1);\n    }\n  };\n};\n\nSubscription.prototype.applyAll = function (applyTo, applyWith) {\n  this.subscriptions.forEach(function (fn) {\n    try {\n      fn.apply(applyTo, applyWith);\n    } catch (error) {\n      console.log(error, error.stack);\n    }\n  }, this);\n};\n\nmodule.exports = Subscription;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  apmSymbol: apmSymbol,\n  patchMethod: patchMethod\n};\n\nfunction apmSymbol(name) {\n  return '__apm_symbol__' + name;\n}\n\nfunction patchMethod(target, name, patchFn) {\n  var proto = target;\n  while (proto && !proto.hasOwnProperty(name)) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  if (!proto && target[name]) {\n    // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n    proto = target;\n  }\n  var delegateName = apmSymbol(name);\n  var delegate;\n  if (proto && !(delegate = proto[delegateName])) {\n    delegate = proto[delegateName] = proto[name];\n    proto[name] = createNamedFn(name, patchFn(delegate, delegateName, name));\n  }\n  return delegate;\n}\n\nfunction createNamedFn(name, delegate) {\n  try {\n    return Function('f', 'return function ' + name + '(){return f(this, arguments)}')(delegate); // eslint-disable-line\n  } catch (e) {\n    // if we fail, we must be CSP, just return delegate.\n    return function () {\n      return delegate(this, arguments);\n    };\n  }\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// export public core APIs.\n\nvar ErrorLogging = __webpack_require__(9);\nvar PerformanceMonitoring = __webpack_require__(16);\n\nvar ServiceFactory = __webpack_require__(22);\nvar utils = __webpack_require__(0);\nmodule.exports = {\n  createServiceFactory: function createServiceFactory() {\n    var serviceFactory = new ServiceFactory();\n    serviceFactory.registerCoreServices();\n    ErrorLogging.registerServices(serviceFactory);\n    PerformanceMonitoring.registerServices(serviceFactory);\n    return serviceFactory;\n  },\n  ServiceFactory: ServiceFactory,\n  patchCommon: __webpack_require__(28),\n  utils: utils\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar rng = __webpack_require__(11);\nvar bytesToUuid = __webpack_require__(12);\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar utils = __webpack_require__(0);\n\nfunction Span(signature, type, options) {\n  var opts = options || {};\n  if (typeof opts.onSpanEnd === 'function') {\n    this.onSpanEnd = opts.onSpanEnd;\n  } else {\n    this.onSpanEnd = function () {};\n  }\n  this.signature = signature;\n  this.type = type;\n  this.ended = false;\n  this._end = null;\n\n  // Start timers\n  this._start = window.performance.now();\n}\n\nSpan.prototype.end = function () {\n  this._end = window.performance.now();\n\n  this.ended = true;\n  this.onSpanEnd(this);\n};\n\nSpan.prototype.duration = function () {\n  if (utils.isUndefined(this.ended) || utils.isUndefined(this._start)) {\n    return null;\n  }\n\n  var diff = this._end - this._start;\n\n  return parseFloat(diff);\n};\n\nmodule.exports = Span;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar bootstrap = __webpack_require__(8);\nvar enabled = bootstrap();\n\nvar apmCore = __webpack_require__(3);\nvar ApmBase = __webpack_require__(31);\n\nvar serviceFactory = apmCore.createServiceFactory();\n\nvar apmBase = new ApmBase(serviceFactory, !enabled);\n\nif (typeof window !== 'undefined') {\n  window.elasticApm = apmBase;\n}\n\nvar _exports = {\n  __esModule: true,\n  default: apmBase.init.bind(apmBase),\n  init: apmBase.init.bind(apmBase),\n  ApmBase: ApmBase,\n  apmBase: apmBase\n};\n\nmodule.exports = _exports;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar alreadyBootstrap = false;\nvar enabled = false;\nmodule.exports = function bootstrap() {\n  if (alreadyBootstrap) {\n    return enabled;\n  }\n  alreadyBootstrap = true;\n\n  var apmCore = __webpack_require__(3);\n  if (apmCore.utils.isPlatformSupported()) {\n    __webpack_require__(30);\n    apmCore.patchCommon();\n    enabled = true;\n  } else {\n    console.log('APM: Platform is not supported!');\n  }\n\n  return enabled;\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar ErrorLogging = __webpack_require__(10);\n\nmodule.exports = {\n  ErrorLogging: ErrorLogging,\n  registerServices: function registerServices(serviceFactory) {\n    serviceFactory.registerServiceCreator('ErrorLogging', function () {\n      var apmService = serviceFactory.getService('ApmServer');\n      var configService = serviceFactory.getService('ConfigService');\n      return new ErrorLogging(apmService, configService);\n    });\n  }\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar uuidv4 = __webpack_require__(4);\nvar StackTraceService = __webpack_require__(13);\n\nvar utils = __webpack_require__(0);\n\nvar ErrorLogging = function () {\n  function ErrorLogging(apmServer, configService) {\n    _classCallCheck(this, ErrorLogging);\n\n    this._apmServer = apmServer;\n    this._configService = configService;\n    this._stackTraceService = new StackTraceService(configService);\n  }\n\n  // errorEvent = {message, filename, lineno, colno, error}\n\n\n  _createClass(ErrorLogging, [{\n    key: 'createErrorDataModel',\n    value: function createErrorDataModel(errorEvent) {\n      var filePath = this._stackTraceService.cleanFilePath(errorEvent.filename);\n      var fileName = this._stackTraceService.filePathToFileName(filePath);\n      var culprit;\n      var frames = this._stackTraceService.createStackTraces(errorEvent);\n      frames = this._stackTraceService.filterInvalidFrames(frames);\n\n      if (!fileName && frames.length) {\n        var lastFrame = frames[frames.length - 1];\n        if (lastFrame.filename) {\n          fileName = lastFrame.filename;\n        } else {\n          // If filename empty, assume inline script\n          fileName = '(inline script)';\n        }\n      }\n\n      if (this._stackTraceService.isFileInline(filePath)) {\n        culprit = '(inline script)';\n      } else {\n        culprit = fileName;\n      }\n\n      var message = errorEvent.message || errorEvent.error && errorEvent.error.message;\n      var errorType = errorEvent.error ? errorEvent.error.name : undefined;\n      if (!errorType) {\n        // Try to extract type from message formatted like 'ReferenceError: Can't find variable: initHighlighting'\n        if (message && message.indexOf(':') > -1) {\n          errorType = message.split(':')[0];\n        } else {\n          errorType = '';\n        }\n      }\n\n      var configContext = this._configService.get('context');\n      var errorContext;\n      if (errorEvent.error) {\n        errorContext = this._getErrorProperties(errorEvent.error);\n      }\n      var browserMetadata = this._getBrowserSpecificMetadata();\n      var context = utils.merge({}, browserMetadata, configContext, errorContext);\n\n      var errorObject = {\n        id: uuidv4(),\n        timestamp: new Date().toISOString(),\n        culprit: culprit,\n        exception: {\n          message: message,\n          stacktrace: frames,\n          type: errorType\n        },\n        context: context\n      };\n      return errorObject;\n    }\n  }, {\n    key: 'logErrorEvent',\n    value: function logErrorEvent(errorEvent) {\n      if (typeof errorEvent === 'undefined') {\n        return;\n      }\n      var errorObject = this.createErrorDataModel(errorEvent);\n      if (typeof errorObject.exception.message === 'undefined') {\n        return;\n      }\n      return this._apmServer.sendErrors([errorObject]);\n    }\n  }, {\n    key: 'registerGlobalEventListener',\n    value: function registerGlobalEventListener() {\n      var errorLogging = this;\n      window.onerror = function (messageOrEvent, source, lineno, colno, error) {\n        var errorEvent;\n        if (typeof messageOrEvent !== 'undefined' && typeof messageOrEvent !== 'string') {\n          errorEvent = messageOrEvent;\n        } else {\n          errorEvent = {\n            message: messageOrEvent,\n            filename: source,\n            lineno: lineno,\n            colno: colno,\n            error: error\n          };\n        }\n        errorLogging.logErrorEvent(errorEvent);\n      };\n    }\n  }, {\n    key: 'logError',\n    value: function logError(messageOrError) {\n      var errorEvent = {};\n      if (typeof messageOrError === 'string') {\n        errorEvent.message = messageOrError;\n      } else {\n        errorEvent.error = messageOrError;\n      }\n      return this.logErrorEvent(errorEvent);\n    }\n  }, {\n    key: '_getErrorProperties',\n    value: function _getErrorProperties(error) {\n      var properties = {};\n      Object.keys(error).forEach(function (key) {\n        if (key === 'stack') return;\n        var val = error[key];\n        if (val === null) return; // null is typeof object and well break the switch below\n        switch (typeof val === 'undefined' ? 'undefined' : _typeof(val)) {\n          case 'function':\n            return;\n          case 'object':\n            // ignore all objects except Dates\n            if (typeof val.toISOString !== 'function') return;\n            val = val.toISOString();\n        }\n        properties[key] = val;\n      });\n      return properties;\n    }\n  }, {\n    key: '_getBrowserSpecificMetadata',\n    value: function _getBrowserSpecificMetadata() {\n      var viewportInfo = utils.getViewPortInfo();\n      var metadata = {\n        'environment': {\n          'browserWidth': viewportInfo.width,\n          'browserHeight': viewportInfo.height,\n          'screenWidth': window.screen.width,\n          'screenHeight': window.screen.height,\n          'language': navigator.language,\n          'userAgent': navigator.userAgent,\n          'platform': navigator.platform\n        },\n        'page': {\n          'referer': document.referrer,\n          'host': document.domain,\n          'location': window.location.href\n        }\n      };\n\n      return metadata;\n    }\n  }]);\n\n  return ErrorLogging;\n}();\n\nmodule.exports = ErrorLogging;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function rng() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar errorStackParser = __webpack_require__(14);\n\nvar StackTraceService = function () {\n  function StackTraceService(configService) {\n    _classCallCheck(this, StackTraceService);\n\n    this._configService = configService;\n  }\n\n  _createClass(StackTraceService, [{\n    key: 'createStackTraces',\n    value: function createStackTraces(errorEvent) {\n      var stackTraceService = this;\n      var error = errorEvent.error;\n\n      var stackTraces;\n      if (error) {\n        stackTraces = errorStackParser.parse(error);\n      }\n\n      if (!stackTraces || stackTraces.length === 0) {\n        stackTraces = [{\n          'fileName': errorEvent.filename,\n          'lineNumber': errorEvent.lineno,\n          'columnNumber': errorEvent.colno\n        }];\n      }\n\n      stackTraces = ErrorStackNormalizer(stackTraces);\n\n      stackTraces = stackTraces.map(function (stack) {\n        if (!stack.fileName && !stack.lineNumber) {\n          return {};\n        }\n        if (!stack.columnNumber && !stack.lineNumber) {\n          return {};\n        }\n\n        var filePath = stackTraceService.cleanFilePath(stack.fileName);\n        var fileName = stackTraceService.filePathToFileName(filePath);\n\n        if (stackTraceService.isFileInline(filePath)) {\n          fileName = '(inline script)';\n        }\n\n        return {\n          'abs_path': stack.fileName,\n          'filename': fileName,\n          'function': stack.functionName || '<anonymous>',\n          'lineno': stack.lineNumber,\n          'colno': stack.columnNumber\n        };\n      });\n\n      return stackTraces;\n    }\n  }, {\n    key: 'filterInvalidFrames',\n    value: function filterInvalidFrames(frames) {\n      var result = [];\n      if (Array.isArray(frames)) {\n        result = frames.filter(function (f) {\n          return typeof f['filename'] !== 'undefined' && typeof f['lineno'] !== 'undefined';\n        });\n      }\n      return result;\n    }\n  }, {\n    key: 'filePathToFileName',\n    value: function filePathToFileName(fileUrl) {\n      var origin = window.location.origin || window.location.protocol + '//' + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n\n      if (fileUrl.indexOf(origin) > -1) {\n        fileUrl = fileUrl.replace(origin + '/', '');\n      }\n\n      return fileUrl;\n    }\n  }, {\n    key: 'cleanFilePath',\n    value: function cleanFilePath(filePath) {\n      if (!filePath) {\n        filePath = '';\n      }\n\n      if (filePath === '<anonymous>') {\n        filePath = '';\n      }\n\n      return filePath;\n    }\n  }, {\n    key: 'isFileInline',\n    value: function isFileInline(fileUrl) {\n      if (fileUrl) {\n        return window.location.href.indexOf(fileUrl) === 0;\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return StackTraceService;\n}();\n\nfunction ErrorStackNormalizer(stackFrames) {\n  return stackFrames.map(function (frame) {\n    if (frame.functionName) {\n      frame.functionName = normalizeFunctionName(frame.functionName);\n    }\n    return frame;\n  });\n}\n\nfunction normalizeFunctionName(fnName) {\n  // SpinderMonkey name convetion (https://developer.mozilla.org/en-US/docs/Tools/Debugger-API/Debugger.Object#Accessor_Properties_of_the_Debugger.Object_prototype)\n\n  // We use a/b to refer to the b defined within a\n  var parts = fnName.split('/');\n  if (parts.length > 1) {\n    fnName = ['Object', parts[parts.length - 1]].join('.');\n  } else {\n    fnName = parts[0];\n  }\n\n  // a< to refer to a function that occurs somewhere within an expression that is assigned to a.\n  fnName = fnName.replace(/.<$/gi, '.<anonymous>');\n\n  // Normalize IE's 'Anonymous function'\n  fnName = fnName.replace(/^Anonymous function$/, '<anonymous>');\n\n  // Always use the last part\n  parts = fnName.split('.');\n  if (parts.length > 1) {\n    fnName = parts[parts.length - 1];\n  } else {\n    fnName = parts[0];\n  }\n\n  return fnName;\n}\n\nmodule.exports = StackTraceService;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n})(undefined, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    function _map(array, fn, thisArg) {\n        if (typeof Array.prototype.map === 'function') {\n            return array.map(fn, thisArg);\n        } else {\n            var output = new Array(array.length);\n            for (var i = 0; i < array.length; i++) {\n                output[i] = fn.call(thisArg, array[i]);\n            }\n            return output;\n        }\n    }\n\n    function _filter(array, fn, thisArg) {\n        if (typeof Array.prototype.filter === 'function') {\n            return array.filter(fn, thisArg);\n        } else {\n            var output = [];\n            for (var i = 0; i < array.length; i++) {\n                if (fn.call(thisArg, array[i])) {\n                    output.push(array[i]);\n                }\n            }\n            return output;\n        }\n    }\n\n    function _indexOf(array, target) {\n        if (typeof Array.prototype.indexOf === 'function') {\n            return array.indexOf(target);\n        } else {\n            for (var i = 0; i < array.length; i++) {\n                if (array[i] === target) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n    }\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = _filter(error.stack.split('\\n'), function (line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return _map(filtered, function (line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = _filter(error.stack.split('\\n'), function (line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return _map(filtered, function (line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame(line);\n                } else {\n                    var tokens = line.split('@');\n                    var locationParts = this.extractLocation(tokens.pop());\n                    var functionName = tokens.join('@') || undefined;\n                    return new StackFrame(functionName, undefined, locationParts[0], locationParts[1], locationParts[2], line);\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame(match[3] || undefined, undefined, match[2], match[1], undefined, lines[i]));\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = _filter(error.stack.split('\\n'), function (line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return _map(filtered, function (line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = tokens.shift() || '';\n                var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n                return new StackFrame(functionName, args, locationParts[0], locationParts[1], locationParts[2], line);\n            }, this);\n        }\n    };\n});\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n})(undefined, function () {\n    'use strict';\n\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {\n        if (functionName !== undefined) {\n            this.setFunctionName(functionName);\n        }\n        if (args !== undefined) {\n            this.setArgs(args);\n        }\n        if (fileName !== undefined) {\n            this.setFileName(fileName);\n        }\n        if (lineNumber !== undefined) {\n            this.setLineNumber(lineNumber);\n        }\n        if (columnNumber !== undefined) {\n            this.setColumnNumber(columnNumber);\n        }\n        if (source !== undefined) {\n            this.setSource(source);\n        }\n    }\n\n    StackFrame.prototype = {\n        getFunctionName: function getFunctionName() {\n            return this.functionName;\n        },\n        setFunctionName: function setFunctionName(v) {\n            this.functionName = String(v);\n        },\n\n        getArgs: function getArgs() {\n            return this.args;\n        },\n        setArgs: function setArgs(v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        // NOTE: Property name may be misleading as it includes the path,\n        // but it somewhat mirrors V8's JavaScriptStackTraceApi\n        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's\n        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14\n        getFileName: function getFileName() {\n            return this.fileName;\n        },\n        setFileName: function setFileName(v) {\n            this.fileName = String(v);\n        },\n\n        getLineNumber: function getLineNumber() {\n            return this.lineNumber;\n        },\n        setLineNumber: function setLineNumber(v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Line Number must be a Number');\n            }\n            this.lineNumber = Number(v);\n        },\n\n        getColumnNumber: function getColumnNumber() {\n            return this.columnNumber;\n        },\n        setColumnNumber: function setColumnNumber(v) {\n            if (!_isNumber(v)) {\n                throw new TypeError('Column Number must be a Number');\n            }\n            this.columnNumber = Number(v);\n        },\n\n        getSource: function getSource() {\n            return this.source;\n        },\n        setSource: function setSource(v) {\n            this.source = String(v);\n        },\n\n        toString: function toString() {\n            var functionName = this.getFunctionName() || '{anonymous}';\n            var args = '(' + (this.getArgs() || []).join(',') + ')';\n            var fileName = this.getFileName() ? '@' + this.getFileName() : '';\n            var lineNumber = _isNumber(this.getLineNumber()) ? ':' + this.getLineNumber() : '';\n            var columnNumber = _isNumber(this.getColumnNumber()) ? ':' + this.getColumnNumber() : '';\n            return functionName + args + fileName + lineNumber + columnNumber;\n        }\n    };\n\n    return StackFrame;\n});\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PerformanceMonitoring = __webpack_require__(17);\nvar TransactionService = __webpack_require__(18);\nvar ZoneService = __webpack_require__(21);\n\nmodule.exports = {\n  PerformanceMonitoring: PerformanceMonitoring,\n  registerServices: function registerServices(serviceFactory) {\n    serviceFactory.registerServiceCreator('ZoneService', function () {\n      var configService = serviceFactory.getService('ConfigService');\n      var loggingService = serviceFactory.getService('LoggingService');\n      return new ZoneService(loggingService, configService);\n    });\n\n    serviceFactory.registerServiceCreator('TransactionService', function () {\n      var configService = serviceFactory.getService('ConfigService');\n      var loggingService = serviceFactory.getService('LoggingService');\n      var zoneService = serviceFactory.getService('ZoneService');\n      return new TransactionService(zoneService, loggingService, configService);\n    });\n\n    serviceFactory.registerServiceCreator('PerformanceMonitoring', function () {\n      var configService = serviceFactory.getService('ConfigService');\n      var loggingService = serviceFactory.getService('LoggingService');\n      var apmService = serviceFactory.getService('ApmServer');\n      var zoneService = serviceFactory.getService('ZoneService');\n      var transactionService = serviceFactory.getService('TransactionService');\n      return new PerformanceMonitoring(apmService, configService, loggingService, zoneService, transactionService);\n    });\n  }\n};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar utils = __webpack_require__(0);\n\nvar PerformanceMonitoring = function () {\n  function PerformanceMonitoring(apmServer, configService, loggingService, zoneService, transactionService) {\n    _classCallCheck(this, PerformanceMonitoring);\n\n    this._apmServer = apmServer;\n    this._configService = configService;\n    this._logginService = loggingService;\n    this._zoneService = zoneService;\n    this._transactionService = transactionService;\n  }\n\n  _createClass(PerformanceMonitoring, [{\n    key: 'init',\n    value: function init() {\n      this._zoneService.initialize(window.Zone.current);\n      var performanceMonitoring = this;\n      this._transactionService.subscribe(function (tr) {\n        var payload = performanceMonitoring.createTransactionPayload(tr);\n        if (payload) {\n          performanceMonitoring._apmServer.addTransaction(payload);\n        }\n      });\n    }\n  }, {\n    key: 'setTransactionContextInfo',\n    value: function setTransactionContextInfo(transaction) {\n      var context = this._configService.get('context');\n      if (context) {\n        transaction.addContextInfo(context);\n      }\n    }\n  }, {\n    key: 'filterTransaction',\n    value: function filterTransaction(tr) {\n      var performanceMonitoring = this;\n      var browserResponsivenessInterval = this._configService.get('browserResponsivenessInterval');\n      var checkBrowserResponsiveness = this._configService.get('checkBrowserResponsiveness');\n\n      if (checkBrowserResponsiveness && !tr.isHardNavigation) {\n        var buffer = performanceMonitoring._configService.get('browserResponsivenessBuffer');\n\n        var duration = tr.duration();\n        var wasBrowserResponsive = performanceMonitoring.checkBrowserResponsiveness(tr, browserResponsivenessInterval, buffer);\n        if (!wasBrowserResponsive) {\n          performanceMonitoring._logginService.debug('Transaction was discarded! browser was not responsive enough during the transaction.', ' duration:', duration, ' browserResponsivenessCounter:', tr.browserResponsivenessCounter, 'interval:', browserResponsivenessInterval);\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: 'prepareTransaction',\n    value: function prepareTransaction(transaction) {\n      var performanceMonitoring = this;\n      transaction.spans.sort(function (spanA, spanB) {\n        return spanA._start - spanB._start;\n      });\n\n      if (performanceMonitoring._configService.get('groupSimilarSpans')) {\n        var similarSpanThreshold = performanceMonitoring._configService.get('similarSpanThreshold');\n        transaction.spans = performanceMonitoring.groupSmallContinuouslySimilarSpans(transaction, similarSpanThreshold);\n      }\n      performanceMonitoring.setTransactionContextInfo(transaction);\n    }\n  }, {\n    key: 'createTransactionDataModel',\n    value: function createTransactionDataModel(transaction) {\n      var configContext = this._configService.get('context');\n      var spans = transaction.spans.map(function (span) {\n        return {\n          name: span.signature,\n          type: span.type,\n          start: span._start,\n          duration: span.duration()\n        };\n      });\n\n      var context = utils.merge({}, configContext, transaction.contextInfo);\n      return {\n        id: transaction.id,\n        timestamp: transaction.timestamp,\n        name: transaction.name,\n        type: transaction.type,\n        duration: transaction.duration(),\n        spans: spans,\n        context: context,\n        marks: transaction.marks\n      };\n    }\n  }, {\n    key: 'createTransactionPayload',\n    value: function createTransactionPayload(transaction) {\n      this.prepareTransaction(transaction);\n      var filtered = this.filterTransaction(transaction);\n      if (filtered) {\n        return this.createTransactionDataModel(transaction);\n      }\n    }\n  }, {\n    key: 'sendTransactions',\n    value: function sendTransactions(transactions) {\n      var payload = transactions.map(this.createTransactionPayload.bind(this)).filter(function (tr) {\n        return tr;\n      });\n      this._logginService.debug('Sending Transactions to apm server.', transactions.length);\n\n      // todo: check if transactions are already being sent\n      var promise = this._apmServer.sendTransactions(payload);\n      return promise;\n    }\n  }, {\n    key: 'convertTransactionsToServerModel',\n    value: function convertTransactionsToServerModel(transactions) {\n      return transactions.map(this.createTransactionDataModel.bind(this));\n    }\n  }, {\n    key: 'groupSmallContinuouslySimilarSpans',\n    value: function groupSmallContinuouslySimilarSpans(transaction, threshold) {\n      var transDuration = transaction.duration();\n      var spans = [];\n      var lastCount = 1;\n      transaction.spans.forEach(function (span, index) {\n        if (spans.length === 0) {\n          spans.push(span);\n        } else {\n          var lastSpan = spans[spans.length - 1];\n\n          var isContinuouslySimilar = lastSpan.type === span.type && lastSpan.signature === span.signature && span.duration() / transDuration < threshold && (span._start - lastSpan._end) / transDuration < threshold;\n\n          var isLastSpan = transaction.spans.length === index + 1;\n\n          if (isContinuouslySimilar) {\n            lastCount++;\n            lastSpan._end = span._end;\n          }\n\n          if (lastCount > 1 && (!isContinuouslySimilar || isLastSpan)) {\n            lastSpan.signature = lastCount + 'x ' + lastSpan.signature;\n            lastCount = 1;\n          }\n\n          if (!isContinuouslySimilar) {\n            spans.push(span);\n          }\n        }\n      });\n      return spans;\n    }\n  }, {\n    key: 'checkBrowserResponsiveness',\n    value: function checkBrowserResponsiveness(transaction, interval, buffer) {\n      var counter = transaction.browserResponsivenessCounter;\n      if (typeof interval === 'undefined' || typeof counter === 'undefined') {\n        return true;\n      }\n\n      var duration = transaction.duration();\n      var expectedCount = Math.floor(duration / interval);\n      var wasBrowserResponsive = counter + buffer >= expectedCount;\n\n      return wasBrowserResponsive;\n    }\n  }]);\n\n  return PerformanceMonitoring;\n}();\n\nmodule.exports = PerformanceMonitoring;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Transaction = __webpack_require__(19);\nvar utils = __webpack_require__(0);\nvar Subscription = __webpack_require__(1);\n\nvar captureHardNavigation = __webpack_require__(20);\n\nfunction TransactionService(zoneService, logger, config) {\n  this._config = config;\n  if (typeof config === 'undefined') {\n    logger.debug('TransactionService: config is not provided');\n  }\n  this._logger = logger;\n  this._zoneService = zoneService;\n\n  this.nextAutoTaskId = 1;\n\n  this.taskMap = {};\n  this.metrics = {};\n\n  this.initialPageLoadName = undefined;\n\n  this._subscription = new Subscription();\n\n  var transactionService = this;\n  this._alreadyCapturedPageLoad = false;\n\n  function onBeforeInvokeTask(task) {\n    if (task.source === 'XMLHttpRequest.send' && task.span && !task.span.ended) {\n      task.span.end();\n    }\n    transactionService.logInTransaction('Executing', task.taskId);\n  }\n  zoneService.spec.onBeforeInvokeTask = onBeforeInvokeTask;\n\n  var self = this;\n\n  function onScheduleTask(task) {\n    if (task.source === 'XMLHttpRequest.send') {\n      var url = task['XHR']['url'];\n      var spanSignature = task['XHR']['method'] + ' ';\n      if (transactionService._config.get('includeXHRQueryString')) {\n        spanSignature = spanSignature + url;\n      } else {\n        var parsed = utils.parseUrl(url);\n        spanSignature = spanSignature + parsed.path;\n      }\n\n      var span = transactionService.startSpan(spanSignature, 'ext.HttpRequest', { 'enableStackFrames': false });\n      task.span = span;\n    } else if (task.type === 'interaction') {\n      if (typeof self.interactionStarted === 'function') {\n        self.interactionStarted(task);\n      }\n    }\n    transactionService.addTask(task.taskId);\n  }\n  zoneService.spec.onScheduleTask = onScheduleTask;\n\n  function onInvokeTask(task) {\n    if (task.source === 'XMLHttpRequest.send' && task.span && !task.span.ended) {\n      task.span.end();\n      transactionService.logInTransaction('xhr late ending');\n      transactionService.setDebugDataOnTransaction('xhrLateEnding', true);\n    }\n    transactionService.removeTask(task.taskId);\n    transactionService.detectFinish();\n  }\n  zoneService.spec.onInvokeTask = onInvokeTask;\n\n  function onCancelTask(task) {\n    transactionService.removeTask(task.taskId);\n    transactionService.detectFinish();\n  }\n  zoneService.spec.onCancelTask = onCancelTask;\n  function onInvokeEnd(task) {\n    logger.trace('onInvokeEnd', 'source:', task.source, 'type:', task.type);\n    transactionService.detectFinish();\n  }\n  zoneService.spec.onInvokeEnd = onInvokeEnd;\n\n  function onInvokeStart(task) {\n    logger.trace('onInvokeStart', 'source:', task.source, 'type:', task.type);\n  }\n  zoneService.spec.onInvokeStart = onInvokeStart;\n}\n\nTransactionService.prototype.createTransaction = function (name, type, options) {\n  var perfOptions = options;\n  if (utils.isUndefined(perfOptions)) {\n    perfOptions = this._config.config;\n  }\n  if (!this._config.isActive() || !this._zoneService.isApmZone()) {\n    return;\n  }\n\n  var tr = new Transaction(name, type, perfOptions, this._logger);\n  tr.setDebugData('zone', this._zoneService.getCurrentZone().name);\n  this._zoneService.set('transaction', tr);\n  if (perfOptions.checkBrowserResponsiveness) {\n    this.startCounter(tr);\n  }\n  return tr;\n};\n\nTransactionService.prototype.createZoneTransaction = function () {\n  return this.createTransaction('ZoneTransaction', 'transaction');\n};\n\nTransactionService.prototype.getCurrentTransaction = function () {\n  if (!this._config.isActive() || !this._zoneService.isApmZone()) {\n    return;\n  }\n  var tr = this._zoneService.get('transaction');\n  if (!utils.isUndefined(tr) && !tr.ended) {\n    return tr;\n  }\n  return this.createZoneTransaction();\n};\n\nTransactionService.prototype.startCounter = function (transaction) {\n  transaction.browserResponsivenessCounter = 0;\n  var interval = this._config.get('browserResponsivenessInterval');\n  if (typeof interval === 'undefined') {\n    this._logger.debug('browserResponsivenessInterval is undefined!');\n    return;\n  }\n  this._zoneService.runOuter(function () {\n    var id = setInterval(function () {\n      if (transaction.ended) {\n        window.clearInterval(id);\n      } else {\n        transaction.browserResponsivenessCounter++;\n      }\n    }, interval);\n  });\n};\n\nTransactionService.prototype.sendPageLoadMetrics = function (name) {\n  var self = this;\n  var perfOptions = this._config.config;\n  var tr;\n\n  tr = this._zoneService.getFromApmZone('transaction');\n\n  var trName = name || this.initialPageLoadName;\n  var unknownName = false;\n  if (!trName) {\n    trName = 'Unknown';\n    unknownName = true;\n  }\n\n  if (tr && tr.name === 'ZoneTransaction') {\n    tr.redefine(trName, 'page-load', perfOptions);\n  } else {\n    tr = new Transaction(trName, 'page-load', perfOptions, this._logger);\n  }\n  tr.isHardNavigation = true;\n  tr.unknownName = unknownName;\n\n  tr.doneCallback = function () {\n    self.applyAsync(function () {\n      var captured = self.capturePageLoadMetrics(tr);\n      if (captured) {\n        self.add(tr);\n      }\n    });\n  };\n  tr.detectFinish();\n  return tr;\n};\n\nTransactionService.prototype.capturePageLoadMetrics = function (tr) {\n  var self = this;\n  var capturePageLoad = self._config.get('capturePageLoad');\n  if (capturePageLoad && !self._alreadyCapturedPageLoad && tr.isHardNavigation) {\n    tr.addMarks(self.metrics);\n    captureHardNavigation(tr);\n    self._alreadyCapturedPageLoad = true;\n    return true;\n  }\n};\n\nTransactionService.prototype.startTransaction = function (name, type) {\n  var self = this;\n  var perfOptions = this._config.config;\n  if (type === 'interaction' && !perfOptions.captureInteractions) {\n    return;\n  }\n\n  // this will create a zone transaction if possible\n  var tr = this.getCurrentTransaction();\n\n  if (tr) {\n    if (tr.name !== 'ZoneTransaction') {\n      // todo: need to handle cases in which the transaction has active spans and/or scheduled tasks\n      this.logInTransaction('Ending early to start a new transaction:', name, type);\n      this._logger.debug('Ending old transaction', tr);\n      tr.end();\n      tr = this.createTransaction(name, type);\n    } else {\n      tr.redefine(name, type, perfOptions);\n    }\n  } else {\n    return;\n  }\n\n  this._logger.debug('TransactionService.startTransaction', tr);\n  tr.doneCallback = function () {\n    self.applyAsync(function () {\n      self._logger.debug('TransactionService transaction finished', tr);\n\n      if (tr.spans.length > 0 && !self.shouldIgnoreTransaction(tr.name)) {\n        self.capturePageLoadMetrics(tr);\n        self.add(tr);\n      }\n    });\n  };\n  return tr;\n};\n\nTransactionService.prototype.applyAsync = function (fn, applyThis, applyArgs) {\n  return this._zoneService.runOuter(function () {\n    return Promise.resolve().then(function () {\n      return fn.apply(applyThis, applyArgs);\n    }, function (reason) {\n      console.log(reason);\n    });\n  });\n};\n\nTransactionService.prototype.shouldIgnoreTransaction = function (transaction_name) {\n  var ignoreList = this._config.get('ignoreTransactions');\n\n  for (var i = 0; i < ignoreList.length; i++) {\n    var element = ignoreList[i];\n    if (typeof element.test === 'function') {\n      if (element.test(transaction_name)) {\n        return true;\n      }\n    } else if (element === transaction_name) {\n      return true;\n    }\n  }\n  return false;\n};\n\nTransactionService.prototype.startSpan = function (signature, type, options) {\n  var trans = this.getCurrentTransaction();\n\n  if (trans) {\n    this._logger.debug('TransactionService.startSpan', signature, type);\n    var span = trans.startSpan(signature, type, options);\n    return span;\n  }\n};\n\nTransactionService.prototype.add = function (transaction) {\n  if (!this._config.isActive()) {\n    return;\n  }\n\n  this._subscription.applyAll(this, [transaction]);\n  this._logger.debug('TransactionService.add', transaction);\n};\n\nTransactionService.prototype.subscribe = function (fn) {\n  return this._subscription.subscribe(fn);\n};\n\nTransactionService.prototype.addTask = function (taskId) {\n  var tr = this.getCurrentTransaction();\n  if (tr) {\n    if (typeof taskId === 'undefined') {\n      taskId = 'autoId' + this.nextAutoTaskId++;\n    }\n    tr.addTask(taskId);\n    this._logger.debug('TransactionService.addTask', taskId);\n  }\n  return taskId;\n};\nTransactionService.prototype.removeTask = function (taskId) {\n  var tr = this._zoneService.get('transaction');\n  if (!utils.isUndefined(tr) && !tr.ended) {\n    tr.removeTask(taskId);\n    this._logger.debug('TransactionService.removeTask', taskId);\n  }\n};\nTransactionService.prototype.logInTransaction = function () {\n  var tr = this._zoneService.get('transaction');\n  if (!utils.isUndefined(tr) && !tr.ended) {\n    tr.debugLog.apply(tr, arguments);\n  }\n};\nTransactionService.prototype.setDebugDataOnTransaction = function setDebugDataOnTransaction(key, value) {\n  var tr = this._zoneService.get('transaction');\n  if (!utils.isUndefined(tr) && !tr.ended) {\n    tr.setDebugData(key, value);\n  }\n};\n\nTransactionService.prototype.detectFinish = function () {\n  var tr = this._zoneService.get('transaction');\n  if (!utils.isUndefined(tr) && !tr.ended) {\n    tr.detectFinish();\n    this._logger.debug('TransactionService.detectFinish');\n  }\n};\n\nmodule.exports = TransactionService;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Span = __webpack_require__(6);\nvar utils = __webpack_require__(0);\nvar uuidv4 = __webpack_require__(4);\n\nvar Transaction = function Transaction(name, type, options, logger) {\n  this.id = uuidv4();\n  this.timestamp = new Date().toISOString();\n  this.metadata = {};\n  this.name = name;\n  this.type = type;\n  this.ended = false;\n  this._isDone = false;\n  this._options = options;\n  this._logger = logger;\n  if (typeof options === 'undefined') {\n    this._options = {};\n  }\n\n  this.contextInfo = {\n    _debug: {}\n  };\n\n  this.marks = {};\n  if (this._options.sendVerboseDebugInfo) {\n    this.contextInfo._debug.log = [];\n    this.debugLog('Transaction', name, type);\n  }\n\n  this.spans = [];\n  this._activeSpans = {};\n\n  this._scheduledTasks = {};\n\n  this.events = {};\n\n  this.doneCallback = function noop() {};\n\n  this._rootSpan = new Span('transaction', 'transaction', { enableStackFrames: false });\n\n  this._startStamp = new Date();\n\n  this.duration = this._rootSpan.duration.bind(this._rootSpan);\n  this.nextId = 0;\n\n  this.isHardNavigation = false;\n};\n\nTransaction.prototype.debugLog = function () {\n  if (this._options.sendVerboseDebugInfo) {\n    var messages = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n    messages.unshift(Date.now().toString());\n    var textMessage = messages.join(' - ');\n    this.contextInfo._debug.log.push(textMessage);\n    if (this._logger) this._logger.debug(textMessage);\n  }\n};\n\nTransaction.prototype.addContextInfo = function (obj) {\n  utils.merge(this.contextInfo, obj);\n};\n\nTransaction.prototype.setDebugData = function setDebugData(key, value) {\n  this.contextInfo._debug[key] = value;\n};\n\nTransaction.prototype.addMarks = function (obj) {\n  this.marks = utils.merge(this.marks, obj);\n};\n\nTransaction.prototype.redefine = function (name, type, options) {\n  this.debugLog('redefine', name, type);\n  this.name = name;\n  this.type = type;\n  this._options = options;\n};\n\nTransaction.prototype.startSpan = function (signature, type, options) {\n  // todo: should not accept more spans if the transaction is alreadyFinished\n  var transaction = this;\n  this.debugLog('startSpan', signature, type);\n  var opts = typeof options === 'undefined' ? {} : options;\n  opts.enableStackFrames = this._options.enableStackFrames === true && opts.enableStackFrames !== false;\n\n  opts.onSpanEnd = function (trc) {\n    transaction._onSpanEnd(trc);\n  };\n\n  var span = new Span(signature, type, opts);\n  span.id = this.nextId;\n  this.nextId++;\n  this._activeSpans[span.id] = span;\n\n  return span;\n};\n\nTransaction.prototype.isFinished = function () {\n  var scheduledTasks = Object.keys(this._scheduledTasks);\n  this.debugLog('isFinished scheduledTasks', scheduledTasks);\n  return scheduledTasks.length === 0;\n};\n\nTransaction.prototype.detectFinish = function () {\n  if (this.isFinished()) this.end();\n};\n\nTransaction.prototype.end = function () {\n  if (this.ended) {\n    return;\n  }\n  this.debugLog('end');\n  this.ended = true;\n\n  this.addContextInfo({\n    url: {\n      location: window.location.href\n    }\n  });\n  this._rootSpan.end();\n\n  if (this.isFinished() === true) {\n    this._finish();\n  }\n};\n\nTransaction.prototype.addTask = function (taskId) {\n  // todo: should not accept more tasks if the transaction is alreadyFinished]\n  this.debugLog('addTask', taskId);\n  this._scheduledTasks[taskId] = taskId;\n};\n\nTransaction.prototype.removeTask = function (taskId) {\n  this.debugLog('removeTask', taskId);\n  this.setDebugData('lastRemovedTask', taskId);\n  delete this._scheduledTasks[taskId];\n};\n\nTransaction.prototype.addEndedSpans = function (existingSpans) {\n  this.spans = this.spans.concat(existingSpans);\n};\n\nTransaction.prototype._onSpanEnd = function (span) {\n  this.spans.push(span);\n  span._scheduledTasks = Object.keys(this._scheduledTasks);\n  // Remove span from _activeSpans\n  delete this._activeSpans[span.id];\n};\n\nTransaction.prototype._finish = function () {\n  if (this._alreadFinished === true) {\n    return;\n  }\n\n  this._alreadFinished = true;\n\n  this._adjustStartToEarliestSpan();\n  this._adjustEndToLatestSpan();\n  this.doneCallback(this);\n};\n\nTransaction.prototype._adjustEndToLatestSpan = function () {\n  var latestSpan = findLatestNonXHRSpan(this.spans);\n\n  if (latestSpan) {\n    this._rootSpan._end = latestSpan._end;\n\n    // set all spans that now are longer than the transaction to\n    // be truncated spans\n    for (var i = 0; i < this.spans.length; i++) {\n      var span = this.spans[i];\n      if (span._end > this._rootSpan._end) {\n        span._end = this._rootSpan._end;\n        span.type = span.type + '.truncated';\n      }\n    }\n  }\n};\n\nTransaction.prototype._adjustStartToEarliestSpan = function () {\n  var span = getEarliestSpan(this.spans);\n\n  if (span && span._start < this._rootSpan._start) {\n    this._rootSpan._start = span._start;\n  }\n};\n\nfunction findLatestNonXHRSpan(spans) {\n  var latestSpan = null;\n  for (var i = 0; i < spans.length; i++) {\n    var span = spans[i];\n    if (span.type && span.type.indexOf('ext') === -1 && span.type !== 'transaction' && (!latestSpan || latestSpan._end < span._end)) {\n      latestSpan = span;\n    }\n  }\n  return latestSpan;\n}\n\nfunction getEarliestSpan(spans) {\n  var earliestSpan = null;\n\n  spans.forEach(function (span) {\n    if (!earliestSpan) {\n      earliestSpan = span;\n    }\n    if (earliestSpan && earliestSpan._start > span._start) {\n      earliestSpan = span;\n    }\n  });\n\n  return earliestSpan;\n}\n\nmodule.exports = Transaction;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Span = __webpack_require__(6);\n\nvar eventPairs = [['domainLookupStart', 'domainLookupEnd', 'DNS lookup'], ['connectStart', 'connectEnd', 'Connect'], ['requestStart', 'responseStart', 'Sending and waiting for first byte'], ['responseStart', 'responseEnd', 'Downloading'], ['domLoading', 'domInteractive', 'Fetching, parsing and sync. execution'], ['domContentLoadedEventStart', 'domContentLoadedEventEnd', '\"DOMContentLoaded\" event handling'], ['loadEventStart', 'loadEventEnd', '\"load\" event handling']];\n\nvar navigationTimingKeys = ['navigationStart', 'unloadEventStart', 'unloadEventEnd', 'redirectStart', 'redirectEnd', 'fetchStart', 'domainLookupStart', 'domainLookupEnd', 'connectStart', 'connectEnd', 'secureConnectionStart', 'requestStart', 'responseStart', 'responseEnd', 'domLoading', 'domInteractive', 'domContentLoadedEventStart', 'domContentLoadedEventEnd', 'domComplete', 'loadEventStart', 'loadEventEnd'];\n\nvar spanThreshold = 5 * 60 * 1000; // 5 minutes\nfunction isValidSpan(transaction, span) {\n  var d = span.duration();\n  return d < spanThreshold && d > 0 && span._start <= transaction._rootSpan._end && span._end <= transaction._rootSpan._end;\n}\n\nmodule.exports = function captureHardNavigation(transaction) {\n  if (transaction.isHardNavigation && window.performance && window.performance.timing) {\n    var baseTime = window.performance.timing.fetchStart;\n    var timings = window.performance.timing;\n\n    transaction._rootSpan._start = 0;\n    transaction.type = 'page-load';\n    for (var i = 0; i < eventPairs.length; i++) {\n      // var transactionStart = eventPairs[0]\n      var start = timings[eventPairs[i][0]];\n      var end = timings[eventPairs[i][1]];\n      if (start && end && end - start !== 0) {\n        var span = new Span(eventPairs[i][2], 'hard-navigation.browser-timing');\n        span._start = timings[eventPairs[i][0]] - baseTime;\n        span.ended = true;\n        span.end();\n        span._end = timings[eventPairs[i][1]] - baseTime;\n        if (isValidSpan(transaction, span)) {\n          transaction.spans.push(span);\n        }\n      }\n    }\n\n    if (window.performance.getEntriesByType) {\n      var entries = window.performance.getEntriesByType('resource');\n\n      var ajaxUrls = transaction.spans.filter(function (span) {\n        return span.type.indexOf('ext.HttpRequest') > -1;\n      }).map(function (span) {\n        return span.signature.split(' ')[1];\n      });\n\n      for (i = 0; i < entries.length; i++) {\n        var entry = entries[i];\n        if (entry.initiatorType && entry.initiatorType === 'xmlhttprequest') {\n          continue;\n        } else if (entry.initiatorType !== 'css' && entry.initiatorType !== 'img' && entry.initiatorType !== 'script' && entry.initiatorType !== 'link') {\n          // is web request? test for css/img before the expensive operation\n          var foundAjaxReq = false;\n          for (var j = 0; j < ajaxUrls.length; j++) {\n            // entry.name.endsWith(ajaxUrls[j])\n            var idx = entry.name.lastIndexOf(ajaxUrls[j]);\n            if (idx > -1 && idx === entry.name.length - ajaxUrls[j].length) {\n              foundAjaxReq = true;\n              break;\n            }\n          }\n          if (foundAjaxReq) {\n            continue;\n          }\n        } else {\n          var kind = 'resource';\n          if (entry.initiatorType) {\n            kind += '.' + entry.initiatorType;\n          }\n\n          span = new Span(entry.name, kind);\n          span._start = entry.startTime;\n          span.ended = true;\n          span.end();\n          span._end = entry.responseEnd;\n          if (isValidSpan(transaction, span)) {\n            transaction.spans.push(span);\n          }\n        }\n      }\n    }\n    transaction._adjustStartToEarliestSpan();\n    transaction._adjustEndToLatestSpan();\n\n    var marks = {\n      agent: {\n        timeToComplete: transaction._rootSpan._end\n      },\n      navigationTiming: {}\n    };\n    var navigationStart = window.performance.timing.navigationStart;\n    navigationTimingKeys.forEach(function (timingKey) {\n      var m = timings[timingKey];\n      if (m) {\n        marks.navigationTiming[timingKey] = m - navigationStart;\n      }\n    });\n    transaction.addMarks(marks);\n  }\n  return 0;\n};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Subscription = __webpack_require__(1);\nvar patchUtils = __webpack_require__(2);\nvar apmTaskSymbol = patchUtils.apmSymbol('taskData');\n\nvar urlSympbol = patchUtils.apmSymbol('url');\nvar methodSymbol = patchUtils.apmSymbol('method');\n\nvar XMLHttpRequest_send = 'XMLHttpRequest.send';\n\nvar apmDataSymbol = patchUtils.apmSymbol('apmData');\n\nvar testTransactionAfterEvents = ['click', 'contextmenu', 'dblclick', 'mousedown', 'keydown', 'keypress', 'keyup']; // leave these out for now: 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover',\nvar testTransactionAfterEventsObj = {};\ntestTransactionAfterEvents.forEach(function (ev) {\n  testTransactionAfterEventsObj[ev] = 1;\n});\n\nfunction ZoneService(logger, config) {\n  this.events = new Subscription();\n\n  var nextId = 0;\n\n  // var zoneService = this\n  function noop() {}\n  var spec = this.spec = {\n    onScheduleTask: noop,\n    onBeforeInvokeTask: noop,\n    onInvokeTask: noop,\n    onCancelTask: noop,\n    onHandleError: noop,\n    onInvokeStart: noop,\n    onInvokeEnd: noop\n  };\n\n  this.zoneConfig = {\n    name: 'apmRootZone',\n    onScheduleTask: function onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n      logger.trace('zoneservice.onScheduleTask', task.source, ' type:', task.type);\n      if (task.type === 'eventTask') {\n        var target = task.data.taskData.target;\n        var eventName = task.data.taskData.eventName;\n\n        if (target && typeof target[apmDataSymbol] === 'undefined') {\n          target[apmDataSymbol] = { registeredEventListeners: {} };\n        }\n\n        if (task.type === 'eventTask' && eventName === 'apmImmediatelyFiringEvent') {\n          task.callback(task.data.taskData);\n          return task;\n        }\n\n        if (target && (eventName === 'readystatechange' || eventName === 'load')) {\n          target[apmDataSymbol].registeredEventListeners[eventName] = { resolved: false };\n        }\n      } else if (task.type === 'macroTask') {\n        logger.trace('Zone: ', targetZone.name);\n        var taskId = nextId++;\n        var apmTask = {\n          taskId: task.source + taskId,\n          source: task.source,\n          type: task.type\n        };\n\n        if (task.source === 'setTimeout') {\n          if (task.data.args[1] === 0 || typeof task.data.args[1] === 'undefined') {\n            task[apmTaskSymbol] = apmTask;\n            spec.onScheduleTask(apmTask);\n          }\n        } else if (task.source === XMLHttpRequest_send) {\n          /*\n                  \"XMLHttpRequest.addEventListener:load\"\n                  \"XMLHttpRequest.addEventListener:error\"\n                  \"XMLHttpRequest.addEventListener:abort\"\n                  \"XMLHttpRequest.send\"\n                  \"XMLHttpRequest.addEventListener:readystatechange\"\n          */\n\n          apmTask['XHR'] = {\n            resolved: false,\n            'send': false,\n            url: task.data.target[urlSympbol],\n            method: task.data.target[methodSymbol]\n\n            // target for event tasks is different instance from the XMLHttpRequest, on mobile browsers\n            // A hack to get the correct target for event tasks\n          };task.data.target.addEventListener('apmImmediatelyFiringEvent', function (event) {\n            if (typeof event.target[apmDataSymbol] !== 'undefined') {\n              task.data.target[apmDataSymbol] = event.target[apmDataSymbol];\n            } else {\n              task.data.target[apmDataSymbol] = event.target[apmDataSymbol] = { registeredEventListeners: {} };\n            }\n          });\n\n          task.data.target[apmDataSymbol].task = apmTask;\n          task.data.target[apmDataSymbol].typeName = 'XMLHttpRequest';\n\n          spec.onScheduleTask(apmTask);\n        }\n      } else if (task.type === 'microTask' && task.source === 'Promise.then') {\n        taskId = nextId++;\n        apmTask = {\n          taskId: task.source + taskId,\n          source: task.source,\n          type: task.type\n        };\n\n        task[apmTaskSymbol] = apmTask;\n        spec.onScheduleTask(apmTask);\n      }\n\n      var delegateTask = parentZoneDelegate.scheduleTask(targetZone, task);\n      return delegateTask;\n    },\n    onInvoke: function onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n      var taskId = nextId++;\n      var apmTask = {\n        taskId: source + taskId,\n        source: source,\n        type: 'invoke'\n      };\n      spec.onInvokeStart(apmTask);\n      var result = delegate.apply(applyThis, applyArgs);\n      spec.onInvokeEnd(apmTask);\n      return result;\n    },\n    onInvokeTask: function onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n      spec.onInvokeStart({ source: task.source, type: task.type });\n      logger.trace('zoneservice.onInvokeTask', task.source, ' type:', task.type);\n      var target = task.target || task.data && task.data.target;\n      var eventName = task.eventName;\n      var result;\n\n      if (target && target[apmDataSymbol].typeName === 'XMLHttpRequest') {\n        var apmData = target[apmDataSymbol];\n        logger.trace('apmData', apmData);\n        var apmTask = apmData.task;\n        if (apmTask && eventName === 'readystatechange' && target.readyState === target.DONE) {\n          apmData.registeredEventListeners['readystatechange'].resolved = true;\n          spec.onBeforeInvokeTask(apmTask);\n        } else if (apmTask && eventName === 'load' && 'load' in apmData.registeredEventListeners) {\n          apmData.registeredEventListeners.load.resolved = true;\n        } else if (apmTask && task.source === XMLHttpRequest_send) {\n          apmTask.XHR.resolved = true;\n        }\n\n        result = parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        if (apmTask && (!apmData.registeredEventListeners['load'] || apmData.registeredEventListeners['load'].resolved) && (!apmData.registeredEventListeners['readystatechange'] || apmData.registeredEventListeners['readystatechange'].resolved) && apmTask.XHR.resolved) {\n          spec.onInvokeTask(apmTask);\n        }\n      } else if (task[apmTaskSymbol] && (task.source === 'setTimeout' || task.source === 'Promise.then')) {\n        spec.onBeforeInvokeTask(task[apmTaskSymbol]);\n        result = parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        spec.onInvokeTask(task[apmTaskSymbol]);\n      } else if (task.type === 'eventTask' && target && eventName in testTransactionAfterEventsObj) {\n        var taskId = nextId++;\n        apmTask = {\n          taskId: task.source + taskId,\n          source: task.source,\n          type: 'interaction',\n          applyArgs: applyArgs\n        };\n\n        spec.onScheduleTask(apmTask);\n\n        // clear spans on the zone transaction\n        result = parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n        spec.onInvokeTask(apmTask);\n      } else {\n        result = parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n      }\n      spec.onInvokeEnd({ source: task.source, type: task.type });\n      return result;\n    },\n    onCancelTask: function onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n      // logger.trace('Zone: ', targetZone.name)\n      var apmTask;\n      if (task.type === 'macroTask') {\n        if (task.source === XMLHttpRequest_send) {\n          apmTask = task.data.target[apmDataSymbol].task;\n          spec.onCancelTask(apmTask);\n        } else if (task[apmTaskSymbol] && task.source === 'setTimeout') {\n          apmTask = task[apmTaskSymbol];\n          spec.onCancelTask(apmTask);\n        }\n      }\n      return parentZoneDelegate.cancelTask(targetZone, task);\n    }\n    // onHandleError: function (parentZoneDelegate, currentZone, targetZone, error) {\n    //   spec.onHandleError(error)\n    //   parentZoneDelegate.handleError(targetZone, error)\n    // }\n  };\n}\n\nZoneService.prototype.initialize = function (zone) {\n  this.outer = zone;\n  this.zone = zone.fork(this.zoneConfig);\n};\n\nZoneService.prototype.set = function (key, value) {\n  window.Zone.current._properties[key] = value;\n};\nZoneService.prototype.get = function (key) {\n  return window.Zone.current.get(key);\n};\n\nZoneService.prototype.getFromApmZone = function (key) {\n  return this.zone.get(key);\n};\nZoneService.prototype.setOnApmZone = function (key, value) {\n  this.zone._properties[key] = value;\n};\n\nZoneService.prototype.getCurrentZone = function () {\n  return window.Zone.current;\n};\n\nZoneService.prototype.isApmZone = function () {\n  return this.zone.name === window.Zone.current.name;\n};\n\nZoneService.prototype.runOuter = function (fn, applyThis, applyArgs) {\n  if (this.outer) {\n    return this.outer.run(fn, applyThis, applyArgs);\n  } else {\n    return fn.apply(applyThis, applyArgs);\n  }\n};\n\nZoneService.prototype.runInApmZone = function runInApmZone(fn, applyThis, applyArgs, source) {\n  return this.zone.run(fn, applyThis, applyArgs, source || 'runInApmZone:' + fn.name);\n};\n\nmodule.exports = ZoneService;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ApmServer = __webpack_require__(23);\nvar ConfigService = __webpack_require__(26);\nvar Logger = __webpack_require__(27);\n\nvar patchUtils = __webpack_require__(2);\nvar utils = __webpack_require__(0);\n\nvar ServiceFactory = function () {\n  function ServiceFactory() {\n    _classCallCheck(this, ServiceFactory);\n\n    this._serviceCreators = {};\n    this._serviceInstances = {};\n    this.initialized = false;\n  }\n\n  _createClass(ServiceFactory, [{\n    key: 'registerCoreServices',\n    value: function registerCoreServices() {\n      var serviceFactory = this;\n\n      this.registerServiceCreator('ConfigService', function () {\n        var configService = new ConfigService();\n        return configService;\n      });\n\n      this.registerServiceInstance('LoggingService', Logger);\n      this.registerServiceCreator('ApmServer', function () {\n        return new ApmServer(serviceFactory.getService('ConfigService'), serviceFactory.getService('LoggingService'));\n      });\n      this.registerServiceInstance('PatchUtils', patchUtils);\n      this.registerServiceInstance('Utils', utils);\n    }\n  }, {\n    key: 'init',\n    value: function init() {\n      if (this.initialized) {\n        return;\n      }\n      this.initialized = true;\n      var serviceFactory = this;\n\n      var configService = serviceFactory.getService('ConfigService');\n      configService.init();\n\n      function setLogLevel(loggingService, configService) {\n        if (configService.get('debug') === true && configService.config.logLevel !== 'trace') {\n          loggingService.setLevel('debug', false);\n        } else {\n          loggingService.setLevel(configService.get('logLevel'), false);\n        }\n      }\n\n      setLogLevel(Logger, configService);\n      configService.subscribeToChange(function (newConfig) {\n        setLogLevel(Logger, configService);\n      });\n\n      var apmServer = serviceFactory.getService('ApmServer');\n      apmServer.init();\n    }\n  }, {\n    key: 'registerServiceCreator',\n    value: function registerServiceCreator(name, creator) {\n      this._serviceCreators[name] = creator;\n    }\n  }, {\n    key: 'registerServiceInstance',\n    value: function registerServiceInstance(name, instance) {\n      this._serviceInstances[name] = instance;\n    }\n  }, {\n    key: 'getService',\n    value: function getService(name) {\n      if (!this._serviceInstances[name]) {\n        if (typeof this._serviceCreators[name] === 'function') {\n          this._serviceInstances[name] = this._serviceCreators[name](this);\n        } else {\n          throw new Error('Can not get service, No creator for: ' + name);\n        }\n      }\n      return this._serviceInstances[name];\n    }\n  }]);\n\n  return ServiceFactory;\n}();\n\nmodule.exports = ServiceFactory;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Queue = __webpack_require__(24);\nvar throttle = __webpack_require__(25);\n\nvar ApmServer = function () {\n  function ApmServer(configService, loggingService) {\n    _classCallCheck(this, ApmServer);\n\n    this._configService = configService;\n    this._loggingService = loggingService;\n    this.logMessages = {\n      invalidConfig: { message: 'Configuration is invalid!', level: 'warn' }\n    };\n\n    this.errorQueue = undefined;\n    this.transactionQueue = undefined;\n\n    this.initialized = false;\n    this._throttledMakeRequest;\n  }\n\n  _createClass(ApmServer, [{\n    key: 'init',\n    value: function init() {\n      if (this.initialized) {\n        return;\n      }\n      this.initialized = true;\n\n      this.initErrorQueue();\n      this.initTransactionQueue();\n      this.initThrottledMakeRequest();\n    }\n  }, {\n    key: 'createServiceObject',\n    value: function createServiceObject() {\n      var cfg = this._configService;\n      var serviceObject = {\n        name: cfg.get('serviceName'),\n        version: cfg.get('serviceVersion'),\n        agent: {\n          name: cfg.get('agentName'),\n          version: cfg.get('agentVersion')\n        },\n        language: {\n          name: 'javascript'\n        }\n      };\n      return serviceObject;\n    }\n  }, {\n    key: 'initThrottledMakeRequest',\n    value: function initThrottledMakeRequest() {\n      var apmServer = this;\n      var throttlingRequestLimit = apmServer._configService.get('throttlingRequestLimit');\n      var throttlingInterval = apmServer._configService.get('throttlingInterval');\n      this._throttledMakeRequest = throttle(apmServer._makeHttpRequest.bind(apmServer), function (method, url) {\n        apmServer._loggingService.warn('ElasticAPM: Dropped request to ' + url + ' due to throttling!');\n      }, {\n        limit: throttlingRequestLimit,\n        interval: throttlingInterval\n      });\n    }\n  }, {\n    key: '_postJson',\n    value: function _postJson(endPoint, payload) {\n      if (!this._throttledMakeRequest) {\n        this.initThrottledMakeRequest();\n      }\n\n      return this._throttledMakeRequest('POST', endPoint, JSON.stringify(payload), { 'Content-Type': 'application/json' });\n    }\n  }, {\n    key: '_makeHttpRequest',\n    value: function _makeHttpRequest(method, url, payload, headers) {\n      return new Promise(function (resolve, reject) {\n        var xhr = new window.XMLHttpRequest();\n        xhr.open(method, url, true);\n        xhr.timeout = 10000;\n\n        if (headers) {\n          for (var header in headers) {\n            if (headers.hasOwnProperty(header)) {\n              xhr.setRequestHeader(header, headers[header]);\n            }\n          }\n        }\n\n        xhr.onreadystatechange = function (evt) {\n          if (xhr.readyState === 4) {\n            var status = xhr.status;\n            if (status === 0 || status > 399 && status < 600) {\n              // An http 4xx or 5xx error. Signal an error.\n              var err = new Error(url + ' HTTP status: ' + status);\n              err.xhr = xhr;\n              reject(err);\n            } else {\n              resolve(xhr.responseText);\n            }\n          }\n        };\n\n        xhr.onerror = function (err) {\n          reject(err);\n        };\n\n        xhr.send(payload);\n      });\n    }\n  }, {\n    key: '_createQueue',\n    value: function _createQueue(onFlush) {\n      var queueLimit = this._configService.get('queueLimit');\n      var flushInterval = this._configService.get('flushInterval');\n      return new Queue(onFlush, {\n        queueLimit: queueLimit,\n        flushInterval: flushInterval\n      });\n    }\n  }, {\n    key: 'initErrorQueue',\n    value: function initErrorQueue() {\n      var apmServer = this;\n      if (this.errorQueue) {\n        this.errorQueue.flush();\n      }\n      this.errorQueue = this._createQueue(function (errors) {\n        var p = apmServer.sendErrors(errors);\n        if (p) {\n          p.then(undefined, function (reason) {\n            apmServer._loggingService.debug('Failed sending errors!', reason);\n          });\n        }\n      });\n    }\n  }, {\n    key: 'initTransactionQueue',\n    value: function initTransactionQueue() {\n      var apmServer = this;\n      if (this.transactionQueue) {\n        this.transactionQueue.flush();\n      }\n      this.transactionQueue = this._createQueue(function (transactions) {\n        var p = apmServer.sendTransactions(transactions);\n        if (p) {\n          p.then(undefined, function (reason) {\n            apmServer._loggingService.debug('Failed sending transactions!', reason);\n          });\n        }\n      });\n    }\n  }, {\n    key: 'addError',\n    value: function addError(error) {\n      if (!this.errorQueue) {\n        this.initErrorQueue();\n      }\n      this.errorQueue.add(error);\n    }\n  }, {\n    key: 'addTransaction',\n    value: function addTransaction(transaction) {\n      if (!this.transactionQueue) {\n        this.initTransactionQueue();\n      }\n      this.transactionQueue.add(transaction);\n    }\n  }, {\n    key: 'warnOnce',\n    value: function warnOnce(logObject) {\n      if (logObject.level === 'warn') {\n        logObject.level = 'debug';\n        this._loggingService.warn(logObject.message);\n      } else {\n        this._loggingService.debug(logObject.message);\n      }\n    }\n  }, {\n    key: 'sendErrors',\n    value: function sendErrors(errors) {\n      if (this._configService.isValid()) {\n        if (errors && errors.length > 0) {\n          var payload = {\n            service: this.createServiceObject(),\n            errors: errors\n          };\n          payload = this._configService.applyFilters(payload);\n          var endPoint = this._configService.getEndpointUrl('errors');\n          return this._postJson(endPoint, payload);\n        }\n      } else {\n        this.warnOnce(this.logMessages.invalidConfig);\n      }\n    }\n  }, {\n    key: 'sendTransactions',\n    value: function sendTransactions(transactions) {\n      if (this._configService.isValid()) {\n        if (transactions && transactions.length > 0) {\n          var payload = {\n            service: this.createServiceObject(),\n            transactions: transactions\n          };\n          payload = this._configService.applyFilters(payload);\n          var endPoint = this._configService.getEndpointUrl('transactions');\n          return this._postJson(endPoint, payload);\n        }\n      } else {\n        this.warnOnce(this.logMessages.invalidConfig);\n      }\n    }\n  }]);\n\n  return ApmServer;\n}();\n\nmodule.exports = ApmServer;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Queue = function () {\n  function Queue(onFlush, opts) {\n    _classCallCheck(this, Queue);\n\n    if (!opts) opts = {};\n    this.onFlush = onFlush;\n    this.items = [];\n    this.queueLimit = opts.queueLimit || -1;\n    this.flushInterval = opts.flushInterval || 0;\n    this.timeoutId = undefined;\n  }\n\n  _createClass(Queue, [{\n    key: '_setTimer',\n    value: function _setTimer() {\n      var _this = this;\n\n      this.timeoutId = setTimeout(function () {\n        _this.flush();\n      }, this.flushInterval);\n    }\n  }, {\n    key: 'flush',\n    value: function flush() {\n      this.onFlush(this.items);\n      this._clear();\n    }\n  }, {\n    key: '_clear',\n    value: function _clear() {\n      if (typeof this.timeoutId !== 'undefined') {\n        clearTimeout(this.timeoutId);\n        this.timeoutId = undefined;\n      }\n      this.items = [];\n    }\n  }, {\n    key: 'add',\n    value: function add(item) {\n      this.items.push(item);\n      if (this.queueLimit !== -1 && this.items.length >= this.queueLimit) {\n        this.flush();\n      } else {\n        if (typeof this.timeoutId === 'undefined') {\n          this._setTimer();\n        }\n      }\n    }\n  }]);\n\n  return Queue;\n}();\n\nmodule.exports = Queue;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction throttle(fn, onThrottle, opts) {\n  var context = opts.context || this;\n  var limit = opts.limit;\n  var interval = opts.interval;\n  var countFn = opts.countFn || function () {};\n  var counter = 0;\n  var timeoutId;\n  return function () {\n    var count = typeof countFn === 'function' && countFn.apply(context, arguments);\n    if (typeof count !== 'number') {\n      count = 1;\n    }\n    counter = counter + count;\n    if (typeof timeoutId === 'undefined') {\n      timeoutId = setTimeout(function () {\n        counter = 0;\n        timeoutId = undefined;\n      }, interval);\n    }\n    if (counter > limit) {\n      if (typeof onThrottle === 'function') {\n        return onThrottle.apply(context, arguments);\n      }\n    } else {\n      return fn.apply(context, arguments);\n    }\n  };\n}\n\nmodule.exports = throttle;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar utils = __webpack_require__(0);\nvar Subscription = __webpack_require__(1);\n\nfunction Config() {\n  this.config = {};\n  this.defaults = {\n    serviceName: '',\n    serviceVersion: '',\n    agentName: 'js-base',\n    agentVersion: '0.3.0',\n    serverUrl: 'http://localhost:8200',\n    serverStringLimit: 1024,\n    serverUrlPrefix: '/v1/client-side',\n    active: true,\n    isInstalled: false,\n    debug: false,\n    logLevel: 'warn',\n    // performance monitoring\n    browserResponsivenessInterval: 500,\n    browserResponsivenessBuffer: 3,\n    checkBrowserResponsiveness: true,\n    enable: true,\n    enableStackFrames: false,\n    groupSimilarSpans: true,\n    similarSpanThreshold: 0.05,\n    captureInteractions: false,\n    sendVerboseDebugInfo: false,\n    includeXHRQueryString: false,\n    capturePageLoad: true,\n    ignoreTransactions: [],\n    throttlingRequestLimit: 20,\n    throttlingInterval: 30000, // 30s\n    queueLimit: 20,\n    flushInterval: 500,\n\n    hasRouterLibrary: false,\n\n    context: {},\n    platform: {}\n  };\n\n  this._changeSubscription = new Subscription();\n  this.filters = [];\n}\n\nConfig.prototype.isActive = function isActive() {\n  return this.get('active');\n};\n\nConfig.prototype.addFilter = function addFilter(cb) {\n  if (typeof cb !== 'function') {\n    throw new Error('Argument to must be function');\n  }\n  this.filters.push(cb);\n};\n\nConfig.prototype.applyFilters = function applyFilters(data) {\n  for (var i = 0; i < this.filters.length; i++) {\n    data = this.filters[i](data);\n    if (!data) {\n      return;\n    }\n  }\n  return data;\n};\n\nConfig.prototype.init = function () {\n  var scriptData = _getConfigFromScript();\n  this.setConfig(scriptData);\n};\n\nConfig.prototype.get = function (key) {\n  return utils.arrayReduce(key.split('.'), function (obj, i) {\n    return obj && obj[i];\n  }, this.config);\n};\n\nConfig.prototype.getEndpointUrl = function getEndpointUrl(endpoint) {\n  var url = this.get('serverUrl') + this.get('serverUrlPrefix') + '/' + endpoint;\n  return url;\n};\n\nConfig.prototype.set = function (key, value) {\n  var levels = key.split('.');\n  var max_level = levels.length - 1;\n  var target = this.config;\n\n  utils.arraySome(levels, function (level, i) {\n    if (typeof level === 'undefined') {\n      return true;\n    }\n    if (i === max_level) {\n      target[level] = value;\n    } else {\n      var obj = target[level] || {};\n      target[level] = obj;\n      target = obj;\n    }\n  });\n};\n\nConfig.prototype.setUserContext = function (userContext) {\n  var context = {};\n  if (typeof userContext.id === 'number') {\n    context.id = userContext.id;\n  } else if (typeof userContext.id === 'string') {\n    context.id = this.truncateString(userContext.id);\n  }\n  if (typeof userContext.username === 'string') {\n    context.username = this.truncateString(userContext.username);\n  }\n  if (typeof userContext.email === 'string') {\n    context.email = this.truncateString(userContext.email);\n  }\n  this.set('context.user', context);\n};\n\nConfig.prototype.setCustomContext = function (customContext) {\n  if (customContext && (typeof customContext === 'undefined' ? 'undefined' : _typeof(customContext)) === 'object') {\n    this.set('context.custom', customContext);\n  }\n};\n\nConfig.prototype.truncateString = function (value) {\n  return String(value).substr(0, this.config.serverStringLimit);\n};\n\nConfig.prototype.setTag = function (key, value) {\n  if (!key) return false;\n  if (!this.config.context.tags) {\n    this.config.context.tags = {};\n  }\n  var skey = key.replace(/[.*]/g, '_');\n  this.config.context.tags[skey] = this.truncateString(value);\n};\n\nConfig.prototype.getAgentName = function () {\n  var version = this.config['agentVersion'];\n  if (!version) {\n    version = 'dev';\n  }\n  return this.get('agentName') + '/' + version;\n};\n\nConfig.prototype.setConfig = function (properties) {\n  properties = properties || {};\n  this.config = utils.merge({}, this.defaults, this.config, properties);\n\n  this._changeSubscription.applyAll(this, [this.config]);\n};\n\nConfig.prototype.subscribeToChange = function (fn) {\n  return this._changeSubscription.subscribe(fn);\n};\n\nConfig.prototype.isValid = function () {\n  var requiredKeys = ['serviceName', 'serverUrl'];\n  var values = utils.arrayMap(requiredKeys, utils.functionBind(function (key) {\n    return this.config[key] === null || this.config[key] === undefined || this.config[key] === '';\n  }, this));\n\n  return utils.arrayIndexOf(values, true) === -1;\n};\n\nvar _getConfigFromScript = function _getConfigFromScript() {\n  var script = utils.getCurrentScript();\n  var config = _getDataAttributesFromNode(script);\n  return config;\n};\n\nfunction _getDataAttributesFromNode(node) {\n  var dataAttrs = {};\n  var dataRegex = /^data\\-([\\w\\-]+)$/;\n\n  if (node) {\n    var attrs = node.attributes;\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (dataRegex.test(attr.nodeName)) {\n        var key = attr.nodeName.match(dataRegex)[1];\n\n        // camelCase key\n        key = utils.arrayMap(key.split('-'), function (group, index) {\n          return index > 0 ? group.charAt(0).toUpperCase() + group.substring(1) : group;\n        }).join('');\n\n        dataAttrs[key] = attr.value || attr.nodeValue;\n      }\n    }\n  }\n\n  return dataAttrs;\n}\n\nConfig.prototype.isPlatformSupported = function () {\n  return typeof Array.prototype.forEach === 'function' && typeof JSON.stringify === 'function' && typeof Function.bind === 'function' && window.performance && typeof window.performance.now === 'function' && utils.isCORSSupported();\n};\n\nmodule.exports = Config;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n})(undefined, function () {\n    \"use strict\";\n\n    var noop = function noop() {};\n    var undefinedType = \"undefined\";\n\n    function realMethod(methodName) {\n        if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType) {\n            return false; // We can't build a real method without a console to log to\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function () {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // these private functions always need `this` to be set properly\n\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n        }\n    }\n\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n    function Logger(name, defaultLevel, factory) {\n        var self = this;\n        var currentLevel;\n        var storageKey = \"loglevel\";\n        if (name) {\n            storageKey += \":\" + name;\n        }\n\n        function persistLevelIfPossible(levelNum) {\n            var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n            // Use localStorage if available\n            try {\n                window.localStorage[storageKey] = levelName;\n                return;\n            } catch (ignore) {}\n\n            // Use session cookie as fallback\n            try {\n                window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n            } catch (ignore) {}\n        }\n\n        function getPersistedLevel() {\n            var storedLevel;\n\n            try {\n                storedLevel = window.localStorage[storageKey];\n            } catch (ignore) {}\n\n            if ((typeof storedLevel === 'undefined' ? 'undefined' : _typeof(storedLevel)) === undefinedType) {\n                try {\n                    var cookie = window.document.cookie;\n                    var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n                    if (location) {\n                        storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                    }\n                } catch (ignore) {}\n            }\n\n            // If the stored level is not valid, treat it as if nothing was stored.\n            if (self.levels[storedLevel] === undefined) {\n                storedLevel = undefined;\n            }\n\n            return storedLevel;\n        }\n\n        /*\n         *\n         * Public API\n         *\n         */\n\n        self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n            \"ERROR\": 4, \"SILENT\": 5 };\n\n        self.methodFactory = factory || defaultMethodFactory;\n\n        self.getLevel = function () {\n            return currentLevel;\n        };\n\n        self.setLevel = function (level, persist) {\n            if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                level = self.levels[level.toUpperCase()];\n            }\n            if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                currentLevel = level;\n                if (persist !== false) {\n                    // defaults to true\n                    persistLevelIfPossible(level);\n                }\n                replaceLoggingMethods.call(self, level, name);\n                if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === undefinedType && level < self.levels.SILENT) {\n                    return \"No console available for logging\";\n                }\n            } else {\n                throw \"log.setLevel() called with invalid level: \" + level;\n            }\n        };\n\n        self.setDefaultLevel = function (level) {\n            if (!getPersistedLevel()) {\n                self.setLevel(level, false);\n            }\n        };\n\n        self.enableAll = function (persist) {\n            self.setLevel(self.levels.TRACE, persist);\n        };\n\n        self.disableAll = function (persist) {\n            self.setLevel(self.levels.SILENT, persist);\n        };\n\n        // Initialize with the right level\n        var initialLevel = getPersistedLevel();\n        if (initialLevel == null) {\n            initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n        }\n        self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Package-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function () {\n        if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefinedType && window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    return defaultLogger;\n});\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar patchXMLHttpRequest = __webpack_require__(29);\n\nfunction patchCommon() {\n  patchXMLHttpRequest();\n}\n\nmodule.exports = patchCommon;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar patchUtils = __webpack_require__(2);\n\nvar urlSympbol = patchUtils.apmSymbol('url');\nvar methodSymbol = patchUtils.apmSymbol('method');\nvar isAsyncSymbol = patchUtils.apmSymbol('isAsync');\n\nmodule.exports = function patchXMLHttpRequest() {\n  patchUtils.patchMethod(window.XMLHttpRequest.prototype, 'open', function (delegate) {\n    return function (self, args) {\n      self[methodSymbol] = args[0];\n      self[urlSympbol] = args[1];\n      self[isAsyncSymbol] = args[2];\n      delegate.apply(self, args);\n    };\n  });\n};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\n(function (global, factory) {\n    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory();\n})(undefined, function () {\n    'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    var Zone$1 = function (global) {\n        var FUNCTION = 'function';\n        var performance = global['performance'];\n        function mark(name) {\n            performance && performance['mark'] && performance['mark'](name);\n        }\n        function performanceMeasure(name, label) {\n            performance && performance['measure'] && performance['measure'](name, label);\n        }\n        mark('Zone');\n        if (global['Zone']) {\n            throw new Error('Zone already loaded.');\n        }\n        var Zone = function () {\n            function Zone(parent, zoneSpec) {\n                this._properties = null;\n                this._parent = parent;\n                this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n                this._properties = zoneSpec && zoneSpec.properties || {};\n                this._zoneDelegate = new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n            }\n            Zone.assertZonePatched = function () {\n                if (global['Promise'] !== patches['ZoneAwarePromise']) {\n                    throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' + 'has been overwritten.\\n' + 'Most likely cause is that a Promise polyfill has been loaded ' + 'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' + 'If you must load one, do so before loading zone.js.)');\n                }\n            };\n            Object.defineProperty(Zone, \"root\", {\n                get: function get() {\n                    var zone = Zone.current;\n                    while (zone.parent) {\n                        zone = zone.parent;\n                    }\n                    return zone;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(Zone, \"current\", {\n                get: function get() {\n                    return _currentZoneFrame.zone;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(Zone, \"currentTask\", {\n                get: function get() {\n                    return _currentTask;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Zone.__load_patch = function (name, fn) {\n                if (patches.hasOwnProperty(name)) {\n                    throw Error('Already loaded patch: ' + name);\n                } else if (!global['__Zone_disable_' + name]) {\n                    var perfName = 'Zone:' + name;\n                    mark(perfName);\n                    patches[name] = fn(global, Zone, _api);\n                    performanceMeasure(perfName, perfName);\n                }\n            };\n            Object.defineProperty(Zone.prototype, \"parent\", {\n                get: function get() {\n                    return this._parent;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(Zone.prototype, \"name\", {\n                get: function get() {\n                    return this._name;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Zone.prototype.get = function (key) {\n                var zone = this.getZoneWith(key);\n                if (zone) return zone._properties[key];\n            };\n            Zone.prototype.getZoneWith = function (key) {\n                var current = this;\n                while (current) {\n                    if (current._properties.hasOwnProperty(key)) {\n                        return current;\n                    }\n                    current = current._parent;\n                }\n                return null;\n            };\n            Zone.prototype.fork = function (zoneSpec) {\n                if (!zoneSpec) throw new Error('ZoneSpec required!');\n                return this._zoneDelegate.fork(this, zoneSpec);\n            };\n            Zone.prototype.wrap = function (callback, source) {\n                if ((typeof callback === 'undefined' ? 'undefined' : _typeof(callback)) !== FUNCTION) {\n                    throw new Error('Expecting function got: ' + callback);\n                }\n                var _callback = this._zoneDelegate.intercept(this, callback, source);\n                var zone = this;\n                return function () {\n                    return zone.runGuarded(_callback, this, arguments, source);\n                };\n            };\n            Zone.prototype.run = function (callback, applyThis, applyArgs, source) {\n                if (applyThis === void 0) {\n                    applyThis = undefined;\n                }\n                if (applyArgs === void 0) {\n                    applyArgs = null;\n                }\n                if (source === void 0) {\n                    source = null;\n                }\n                _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n                try {\n                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                } finally {\n                    _currentZoneFrame = _currentZoneFrame.parent;\n                }\n            };\n            Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {\n                if (applyThis === void 0) {\n                    applyThis = null;\n                }\n                if (applyArgs === void 0) {\n                    applyArgs = null;\n                }\n                if (source === void 0) {\n                    source = null;\n                }\n                _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n                try {\n                    try {\n                        return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n                    } catch (error) {\n                        if (this._zoneDelegate.handleError(this, error)) {\n                            throw error;\n                        }\n                    }\n                } finally {\n                    _currentZoneFrame = _currentZoneFrame.parent;\n                }\n            };\n            Zone.prototype.runTask = function (task, applyThis, applyArgs) {\n                if (task.zone != this) {\n                    throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n                }\n                // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n                // will run in notScheduled(canceled) state, we should not try to\n                // run such kind of task but just return\n                // we have to define an variable here, if not\n                // typescript compiler will complain below\n                var isNotScheduled = task.state === notScheduled;\n                if (isNotScheduled && task.type === eventTask) {\n                    return;\n                }\n                var reEntryGuard = task.state != running;\n                reEntryGuard && task._transitionTo(running, scheduled);\n                task.runCount++;\n                var previousTask = _currentTask;\n                _currentTask = task;\n                _currentZoneFrame = { parent: _currentZoneFrame, zone: this };\n                try {\n                    if (task.type == macroTask && task.data && !task.data.isPeriodic) {\n                        task.cancelFn = null;\n                    }\n                    try {\n                        return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n                    } catch (error) {\n                        if (this._zoneDelegate.handleError(this, error)) {\n                            throw error;\n                        }\n                    }\n                } finally {\n                    // if the task's state is notScheduled or unknown, then it has already been cancelled\n                    // we should not reset the state to scheduled\n                    if (task.state !== notScheduled && task.state !== unknown) {\n                        if (task.type == eventTask || task.data && task.data.isPeriodic) {\n                            reEntryGuard && task._transitionTo(scheduled, running);\n                        } else {\n                            task.runCount = 0;\n                            this._updateTaskCount(task, -1);\n                            reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);\n                        }\n                    }\n                    _currentZoneFrame = _currentZoneFrame.parent;\n                    _currentTask = previousTask;\n                }\n            };\n            Zone.prototype.scheduleTask = function (task) {\n                if (task.zone && task.zone !== this) {\n                    // check if the task was rescheduled, the newZone\n                    // should not be the children of the original zone\n                    var newZone = this;\n                    while (newZone) {\n                        if (newZone === task.zone) {\n                            throw Error(\"can not reschedule task to \" + this.name + \" which is descendants of the original zone \" + task.zone.name);\n                        }\n                        newZone = newZone.parent;\n                    }\n                }\n                task._transitionTo(scheduling, notScheduled);\n                var zoneDelegates = [];\n                task._zoneDelegates = zoneDelegates;\n                task._zone = this;\n                try {\n                    task = this._zoneDelegate.scheduleTask(this, task);\n                } catch (err) {\n                    // should set task's state to unknown when scheduleTask throw error\n                    // because the err may from reschedule, so the fromState maybe notScheduled\n                    task._transitionTo(unknown, scheduling, notScheduled);\n                    // TODO: @JiaLiPassion, should we check the result from handleError?\n                    this._zoneDelegate.handleError(this, err);\n                    throw err;\n                }\n                if (task._zoneDelegates === zoneDelegates) {\n                    // we have to check because internally the delegate can reschedule the task.\n                    this._updateTaskCount(task, 1);\n                }\n                if (task.state == scheduling) {\n                    task._transitionTo(scheduled, scheduling);\n                }\n                return task;\n            };\n            Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {\n                return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, null));\n            };\n            Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {\n                return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n            };\n            Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {\n                return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n            };\n            Zone.prototype.cancelTask = function (task) {\n                if (task.zone != this) throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n                task._transitionTo(canceling, scheduled, running);\n                try {\n                    this._zoneDelegate.cancelTask(this, task);\n                } catch (err) {\n                    // if error occurs when cancelTask, transit the state to unknown\n                    task._transitionTo(unknown, canceling);\n                    this._zoneDelegate.handleError(this, err);\n                    throw err;\n                }\n                this._updateTaskCount(task, -1);\n                task._transitionTo(notScheduled, canceling);\n                task.runCount = 0;\n                return task;\n            };\n            Zone.prototype._updateTaskCount = function (task, count) {\n                var zoneDelegates = task._zoneDelegates;\n                if (count == -1) {\n                    task._zoneDelegates = null;\n                }\n                for (var i = 0; i < zoneDelegates.length; i++) {\n                    zoneDelegates[i]._updateTaskCount(task.type, count);\n                }\n            };\n            return Zone;\n        }();\n        Zone.__symbol__ = __symbol__;\n        var DELEGATE_ZS = {\n            name: '',\n            onHasTask: function onHasTask(delegate, _, target, hasTaskState) {\n                return delegate.hasTask(target, hasTaskState);\n            },\n            onScheduleTask: function onScheduleTask(delegate, _, target, task) {\n                return delegate.scheduleTask(target, task);\n            },\n            onInvokeTask: function onInvokeTask(delegate, _, target, task, applyThis, applyArgs) {\n                return delegate.invokeTask(target, task, applyThis, applyArgs);\n            },\n            onCancelTask: function onCancelTask(delegate, _, target, task) {\n                return delegate.cancelTask(target, task);\n            }\n        };\n        var ZoneDelegate = function () {\n            function ZoneDelegate(zone, parentDelegate, zoneSpec) {\n                this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };\n                this.zone = zone;\n                this._parentDelegate = parentDelegate;\n                this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n                this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n                this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);\n                this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n                this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n                this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);\n                this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n                this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n                this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);\n                this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n                this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n                this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);\n                this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n                this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n                this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);\n                this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n                this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n                this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);\n                this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n                this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n                this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);\n                this._hasTaskZS = null;\n                this._hasTaskDlgt = null;\n                this._hasTaskDlgtOwner = null;\n                this._hasTaskCurrZone = null;\n                var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n                var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n                if (zoneSpecHasTask || parentHasTask) {\n                    // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n                    // a case all task related interceptors must go through this ZD. We can't short circuit it.\n                    this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n                    this._hasTaskDlgt = parentDelegate;\n                    this._hasTaskDlgtOwner = this;\n                    this._hasTaskCurrZone = zone;\n                    if (!zoneSpec.onScheduleTask) {\n                        this._scheduleTaskZS = DELEGATE_ZS;\n                        this._scheduleTaskDlgt = parentDelegate;\n                        this._scheduleTaskCurrZone = this.zone;\n                    }\n                    if (!zoneSpec.onInvokeTask) {\n                        this._invokeTaskZS = DELEGATE_ZS;\n                        this._invokeTaskDlgt = parentDelegate;\n                        this._invokeTaskCurrZone = this.zone;\n                    }\n                    if (!zoneSpec.onCancelTask) {\n                        this._cancelTaskZS = DELEGATE_ZS;\n                        this._cancelTaskDlgt = parentDelegate;\n                        this._cancelTaskCurrZone = this.zone;\n                    }\n                }\n            }\n            ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {\n                return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone(targetZone, zoneSpec);\n            };\n            ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {\n                return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;\n            };\n            ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {\n                return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);\n            };\n            ZoneDelegate.prototype.handleError = function (targetZone, error) {\n                return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;\n            };\n            ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {\n                var returnTask = task;\n                if (this._scheduleTaskZS) {\n                    if (this._hasTaskZS) {\n                        returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n                    }\n                    returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);\n                    if (!returnTask) returnTask = task;\n                } else {\n                    if (task.scheduleFn) {\n                        task.scheduleFn(task);\n                    } else if (task.type == microTask) {\n                        scheduleMicroTask(task);\n                    } else {\n                        throw new Error('Task is missing scheduleFn.');\n                    }\n                }\n                return returnTask;\n            };\n            ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {\n                return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);\n            };\n            ZoneDelegate.prototype.cancelTask = function (targetZone, task) {\n                var value;\n                if (this._cancelTaskZS) {\n                    value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n                } else {\n                    if (!task.cancelFn) {\n                        throw Error('Task is not cancelable');\n                    }\n                    value = task.cancelFn(task);\n                }\n                return value;\n            };\n            ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {\n                // hasTask should not throw error so other ZoneDelegate\n                // can still trigger hasTask callback\n                try {\n                    return this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n                } catch (err) {\n                    this.handleError(targetZone, err);\n                }\n            };\n            ZoneDelegate.prototype._updateTaskCount = function (type, count) {\n                var counts = this._taskCounts;\n                var prev = counts[type];\n                var next = counts[type] = prev + count;\n                if (next < 0) {\n                    return; // throw new Error('More tasks executed then were scheduled.');\n                }\n                if (prev == 0 || next == 0) {\n                    var isEmpty = {\n                        microTask: counts['microTask'] > 0,\n                        macroTask: counts['macroTask'] > 0,\n                        eventTask: counts['eventTask'] > 0,\n                        change: type\n                    };\n                    this.hasTask(this.zone, isEmpty);\n                }\n            };\n            return ZoneDelegate;\n        }();\n        var ZoneTask = function () {\n            function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {\n                this._zone = null;\n                this.runCount = 0;\n                this._zoneDelegates = null;\n                this._state = 'notScheduled';\n                this.type = type;\n                this.source = source;\n                this.data = options;\n                this.scheduleFn = scheduleFn;\n                this.cancelFn = cancelFn;\n                this.callback = callback;\n                var self = this;\n                if (type === eventTask && options && options.isUsingGlobalCallback) {\n                    this.invoke = ZoneTask.invokeTask;\n                } else {\n                    this.invoke = function () {\n                        return ZoneTask.invokeTask.apply(global, [self, this, arguments]);\n                    };\n                }\n            }\n            ZoneTask.invokeTask = function (task, target, args) {\n                if (!task) {\n                    task = this;\n                }\n                _numberOfNestedTaskFrames++;\n                try {\n                    task.runCount++;\n                    return task.zone.runTask(task, target, args);\n                } finally {\n                    if (_numberOfNestedTaskFrames == 1) {\n                        drainMicroTaskQueue();\n                    }\n                    _numberOfNestedTaskFrames--;\n                }\n            };\n            Object.defineProperty(ZoneTask.prototype, \"zone\", {\n                get: function get() {\n                    return this._zone;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(ZoneTask.prototype, \"state\", {\n                get: function get() {\n                    return this._state;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            ZoneTask.prototype.cancelScheduleRequest = function () {\n                this._transitionTo(notScheduled, scheduling);\n            };\n            ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {\n                if (this._state === fromState1 || this._state === fromState2) {\n                    this._state = toState;\n                    if (toState == notScheduled) {\n                        this._zoneDelegates = null;\n                    }\n                } else {\n                    throw new Error(this.type + \" '\" + this.source + \"': can not transition to '\" + toState + \"', expecting state '\" + fromState1 + \"'\" + (fromState2 ? ' or \\'' + fromState2 + '\\'' : '') + \", was '\" + this._state + \"'.\");\n                }\n            };\n            ZoneTask.prototype.toString = function () {\n                if (this.data && typeof this.data.handleId !== 'undefined') {\n                    return this.data.handleId;\n                } else {\n                    return Object.prototype.toString.call(this);\n                }\n            };\n            // add toJSON method to prevent cyclic error when\n            // call JSON.stringify(zoneTask)\n            ZoneTask.prototype.toJSON = function () {\n                return {\n                    type: this.type,\n                    state: this.state,\n                    source: this.source,\n                    zone: this.zone.name,\n                    runCount: this.runCount\n                };\n            };\n            return ZoneTask;\n        }();\n        //////////////////////////////////////////////////////\n        //////////////////////////////////////////////////////\n        ///  MICROTASK QUEUE\n        //////////////////////////////////////////////////////\n        //////////////////////////////////////////////////////\n        var symbolSetTimeout = __symbol__('setTimeout');\n        var symbolPromise = __symbol__('Promise');\n        var symbolThen = __symbol__('then');\n        var _microTaskQueue = [];\n        var _isDrainingMicrotaskQueue = false;\n        var nativeMicroTaskQueuePromise;\n        function scheduleMicroTask(task) {\n            // if we are not running in any task, and there has not been anything scheduled\n            // we must bootstrap the initial task creation by manually scheduling the drain\n            if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n                // We are not running in Task, so we need to kickstart the microtask queue.\n                if (!nativeMicroTaskQueuePromise) {\n                    if (global[symbolPromise]) {\n                        nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n                    }\n                }\n                if (nativeMicroTaskQueuePromise) {\n                    nativeMicroTaskQueuePromise[symbolThen](drainMicroTaskQueue);\n                } else {\n                    global[symbolSetTimeout](drainMicroTaskQueue, 0);\n                }\n            }\n            task && _microTaskQueue.push(task);\n        }\n        function drainMicroTaskQueue() {\n            if (!_isDrainingMicrotaskQueue) {\n                _isDrainingMicrotaskQueue = true;\n                while (_microTaskQueue.length) {\n                    var queue = _microTaskQueue;\n                    _microTaskQueue = [];\n                    for (var i = 0; i < queue.length; i++) {\n                        var task = queue[i];\n                        try {\n                            task.zone.runTask(task, null, null);\n                        } catch (error) {\n                            _api.onUnhandledError(error);\n                        }\n                    }\n                }\n                var showError = !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];\n                _api.microtaskDrainDone();\n                _isDrainingMicrotaskQueue = false;\n            }\n        }\n        //////////////////////////////////////////////////////\n        //////////////////////////////////////////////////////\n        ///  BOOTSTRAP\n        //////////////////////////////////////////////////////\n        //////////////////////////////////////////////////////\n        var NO_ZONE = { name: 'NO ZONE' };\n        var notScheduled = 'notScheduled',\n            scheduling = 'scheduling',\n            scheduled = 'scheduled',\n            running = 'running',\n            canceling = 'canceling',\n            unknown = 'unknown';\n        var microTask = 'microTask',\n            macroTask = 'macroTask',\n            eventTask = 'eventTask';\n        var patches = {};\n        var _api = {\n            symbol: __symbol__,\n            currentZoneFrame: function currentZoneFrame() {\n                return _currentZoneFrame;\n            },\n            onUnhandledError: noop,\n            microtaskDrainDone: noop,\n            scheduleMicroTask: scheduleMicroTask,\n            showUncaughtError: function showUncaughtError() {\n                return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];\n            },\n            patchEventTarget: function patchEventTarget() {\n                return [];\n            },\n            patchOnProperties: noop,\n            patchMethod: function patchMethod() {\n                return noop;\n            },\n            patchArguments: function patchArguments() {\n                return noop;\n            },\n            setNativePromise: function setNativePromise(NativePromise) {\n                // sometimes NativePromise.resolve static function\n                // is not ready yet, (such as core-js/es6.promise)\n                // so we need to check here.\n                if (NativePromise && _typeof(NativePromise.resolve) === FUNCTION) {\n                    nativeMicroTaskQueuePromise = NativePromise.resolve(0);\n                }\n            }\n        };\n        var symbolRootZoneSpec = '__rootZoneSpec__';\n        var rootZone = new Zone(null, null);\n        if (global[symbolRootZoneSpec]) {\n            rootZone = rootZone.fork(global[symbolRootZoneSpec]);\n            delete global[symbolRootZoneSpec];\n        }\n        var _currentZoneFrame = { parent: null, zone: rootZone };\n        var _currentTask = null;\n        var _numberOfNestedTaskFrames = 0;\n        function noop() {}\n        function __symbol__(name) {\n            return '__zone_symbol__' + name;\n        }\n        performanceMeasure('Zone', 'Zone');\n        return global['Zone'] = Zone;\n    }(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('ZoneAwarePromise', function (global, Zone, api) {\n        function readableObjectToString(obj) {\n            if (obj && obj.toString === Object.prototype.toString) {\n                var className = obj.constructor && obj.constructor.name;\n                return (className ? className : '') + ': ' + JSON.stringify(obj);\n            }\n            return obj ? obj.toString() : Object.prototype.toString.call(obj);\n        }\n        var __symbol__ = api.symbol;\n        var _uncaughtPromiseErrors = [];\n        var symbolPromise = __symbol__('Promise');\n        var symbolThen = __symbol__('then');\n        var creationTrace = '__creationTrace__';\n        api.onUnhandledError = function (e) {\n            if (api.showUncaughtError()) {\n                var rejection = e && e.rejection;\n                if (rejection) {\n                    console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n                } else {\n                    console.error(e);\n                }\n            }\n        };\n        api.microtaskDrainDone = function () {\n            while (_uncaughtPromiseErrors.length) {\n                var _loop_1 = function _loop_1() {\n                    var uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n                    try {\n                        uncaughtPromiseError.zone.runGuarded(function () {\n                            throw uncaughtPromiseError;\n                        });\n                    } catch (error) {\n                        handleUnhandledRejection(error);\n                    }\n                };\n                while (_uncaughtPromiseErrors.length) {\n                    _loop_1();\n                }\n            }\n        };\n        var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');\n        function handleUnhandledRejection(e) {\n            api.onUnhandledError(e);\n            try {\n                var handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n                if (handler && typeof handler === 'function') {\n                    handler.apply(this, [e]);\n                }\n            } catch (err) {}\n        }\n        function isThenable(value) {\n            return value && value.then;\n        }\n        function forwardResolution(value) {\n            return value;\n        }\n        function forwardRejection(rejection) {\n            return ZoneAwarePromise.reject(rejection);\n        }\n        var symbolState = __symbol__('state');\n        var symbolValue = __symbol__('value');\n        var source = 'Promise.then';\n        var UNRESOLVED = null;\n        var RESOLVED = true;\n        var REJECTED = false;\n        var REJECTED_NO_CATCH = 0;\n        function makeResolver(promise, state) {\n            return function (v) {\n                try {\n                    resolvePromise(promise, state, v);\n                } catch (err) {\n                    resolvePromise(promise, false, err);\n                }\n                // Do not return value or you will break the Promise spec.\n            };\n        }\n        var once = function once() {\n            var wasCalled = false;\n            return function wrapper(wrappedFunction) {\n                return function () {\n                    if (wasCalled) {\n                        return;\n                    }\n                    wasCalled = true;\n                    wrappedFunction.apply(null, arguments);\n                };\n            };\n        };\n        var TYPE_ERROR = 'Promise resolved with itself';\n        var OBJECT = 'object';\n        var FUNCTION = 'function';\n        var CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');\n        // Promise Resolution\n        function resolvePromise(promise, state, value) {\n            var onceWrapper = once();\n            if (promise === value) {\n                throw new TypeError(TYPE_ERROR);\n            }\n            if (promise[symbolState] === UNRESOLVED) {\n                // should only get value.then once based on promise spec.\n                var then = null;\n                try {\n                    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === OBJECT || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === FUNCTION) {\n                        then = value && value.then;\n                    }\n                } catch (err) {\n                    onceWrapper(function () {\n                        resolvePromise(promise, false, err);\n                    })();\n                    return promise;\n                }\n                // if (value instanceof ZoneAwarePromise) {\n                if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {\n                    clearRejectedNoCatch(value);\n                    resolvePromise(promise, value[symbolState], value[symbolValue]);\n                } else if (state !== REJECTED && (typeof then === 'undefined' ? 'undefined' : _typeof(then)) === FUNCTION) {\n                    try {\n                        then.apply(value, [onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false))]);\n                    } catch (err) {\n                        onceWrapper(function () {\n                            resolvePromise(promise, false, err);\n                        })();\n                    }\n                } else {\n                    promise[symbolState] = state;\n                    var queue = promise[symbolValue];\n                    promise[symbolValue] = value;\n                    // record task information in value when error occurs, so we can\n                    // do some additional work such as render longStackTrace\n                    if (state === REJECTED && value instanceof Error) {\n                        // check if longStackTraceZone is here\n                        var trace = Zone.currentTask && Zone.currentTask.data && Zone.currentTask.data[creationTrace];\n                        if (trace) {\n                            // only keep the long stack trace into error when in longStackTraceZone\n                            Object.defineProperty(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });\n                        }\n                    }\n                    for (var i = 0; i < queue.length;) {\n                        scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n                    }\n                    if (queue.length == 0 && state == REJECTED) {\n                        promise[symbolState] = REJECTED_NO_CATCH;\n                        try {\n                            // try to print more readable error log\n                            throw new Error('Uncaught (in promise): ' + readableObjectToString(value) + (value && value.stack ? '\\n' + value.stack : ''));\n                        } catch (err) {\n                            var error_1 = err;\n                            error_1.rejection = value;\n                            error_1.promise = promise;\n                            error_1.zone = Zone.current;\n                            error_1.task = Zone.currentTask;\n                            _uncaughtPromiseErrors.push(error_1);\n                            api.scheduleMicroTask(); // to make sure that it is running\n                        }\n                    }\n                }\n            }\n            // Resolving an already resolved promise is a noop.\n            return promise;\n        }\n        var REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');\n        function clearRejectedNoCatch(promise) {\n            if (promise[symbolState] === REJECTED_NO_CATCH) {\n                // if the promise is rejected no catch status\n                // and queue.length > 0, means there is a error handler\n                // here to handle the rejected promise, we should trigger\n                // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n                // eventHandler\n                try {\n                    var handler = Zone[REJECTION_HANDLED_HANDLER];\n                    if (handler && (typeof handler === 'undefined' ? 'undefined' : _typeof(handler)) === FUNCTION) {\n                        handler.apply(this, [{ rejection: promise[symbolValue], promise: promise }]);\n                    }\n                } catch (err) {}\n                promise[symbolState] = REJECTED;\n                for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {\n                    if (promise === _uncaughtPromiseErrors[i].promise) {\n                        _uncaughtPromiseErrors.splice(i, 1);\n                    }\n                }\n            }\n        }\n        function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n            clearRejectedNoCatch(promise);\n            var delegate = promise[symbolState] ? (typeof onFulfilled === 'undefined' ? 'undefined' : _typeof(onFulfilled)) === FUNCTION ? onFulfilled : forwardResolution : (typeof onRejected === 'undefined' ? 'undefined' : _typeof(onRejected)) === FUNCTION ? onRejected : forwardRejection;\n            zone.scheduleMicroTask(source, function () {\n                try {\n                    resolvePromise(chainPromise, true, zone.run(delegate, undefined, [promise[symbolValue]]));\n                } catch (error) {\n                    resolvePromise(chainPromise, false, error);\n                }\n            });\n        }\n        var ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';\n        var ZoneAwarePromise = function () {\n            function ZoneAwarePromise(executor) {\n                var promise = this;\n                if (!(promise instanceof ZoneAwarePromise)) {\n                    throw new Error('Must be an instanceof Promise.');\n                }\n                promise[symbolState] = UNRESOLVED;\n                promise[symbolValue] = []; // queue;\n                try {\n                    executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));\n                } catch (error) {\n                    resolvePromise(promise, false, error);\n                }\n            }\n            ZoneAwarePromise.toString = function () {\n                return ZONE_AWARE_PROMISE_TO_STRING;\n            };\n            ZoneAwarePromise.resolve = function (value) {\n                return resolvePromise(new this(null), RESOLVED, value);\n            };\n            ZoneAwarePromise.reject = function (error) {\n                return resolvePromise(new this(null), REJECTED, error);\n            };\n            ZoneAwarePromise.race = function (values) {\n                var resolve;\n                var reject;\n                var promise = new this(function (res, rej) {\n                    resolve = res;\n                    reject = rej;\n                });\n                function onResolve(value) {\n                    promise && (promise = null || resolve(value));\n                }\n                function onReject(error) {\n                    promise && (promise = null || reject(error));\n                }\n                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n                    var value = values_1[_i];\n                    if (!isThenable(value)) {\n                        value = this.resolve(value);\n                    }\n                    value.then(onResolve, onReject);\n                }\n                return promise;\n            };\n            ZoneAwarePromise.all = function (values) {\n                var resolve;\n                var reject;\n                var promise = new this(function (res, rej) {\n                    resolve = res;\n                    reject = rej;\n                });\n                var count = 0;\n                var resolvedValues = [];\n                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                    var value = values_2[_i];\n                    if (!isThenable(value)) {\n                        value = this.resolve(value);\n                    }\n                    value.then(function (index) {\n                        return function (value) {\n                            resolvedValues[index] = value;\n                            count--;\n                            if (!count) {\n                                resolve(resolvedValues);\n                            }\n                        };\n                    }(count), reject);\n                    count++;\n                }\n                if (!count) resolve(resolvedValues);\n                return promise;\n            };\n            ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {\n                var chainPromise = new this.constructor(null);\n                var zone = Zone.current;\n                if (this[symbolState] == UNRESOLVED) {\n                    this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n                } else {\n                    scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n                }\n                return chainPromise;\n            };\n            ZoneAwarePromise.prototype.catch = function (onRejected) {\n                return this.then(null, onRejected);\n            };\n            return ZoneAwarePromise;\n        }();\n        // Protect against aggressive optimizers dropping seemingly unused properties.\n        // E.g. Closure Compiler in advanced mode.\n        ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n        ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n        ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n        ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n        var NativePromise = global[symbolPromise] = global['Promise'];\n        var ZONE_AWARE_PROMISE = Zone.__symbol__('ZoneAwarePromise');\n        var desc = Object.getOwnPropertyDescriptor(global, 'Promise');\n        if (!desc || desc.configurable) {\n            desc && delete desc.writable;\n            desc && delete desc.value;\n            if (!desc) {\n                desc = { configurable: true, enumerable: true };\n            }\n            desc.get = function () {\n                // if we already set ZoneAwarePromise, use patched one\n                // otherwise return native one.\n                return global[ZONE_AWARE_PROMISE] ? global[ZONE_AWARE_PROMISE] : global[symbolPromise];\n            };\n            desc.set = function (NewNativePromise) {\n                if (NewNativePromise === ZoneAwarePromise) {\n                    // if the NewNativePromise is ZoneAwarePromise\n                    // save to global\n                    global[ZONE_AWARE_PROMISE] = NewNativePromise;\n                } else {\n                    // if the NewNativePromise is not ZoneAwarePromise\n                    // for example: after load zone.js, some library just\n                    // set es6-promise to global, if we set it to global\n                    // directly, assertZonePatched will fail and angular\n                    // will not loaded, so we just set the NewNativePromise\n                    // to global[symbolPromise], so the result is just like\n                    // we load ES6 Promise before zone.js\n                    global[symbolPromise] = NewNativePromise;\n                    if (!NewNativePromise.prototype[symbolThen]) {\n                        patchThen(NewNativePromise);\n                    }\n                    api.setNativePromise(NewNativePromise);\n                }\n            };\n            Object.defineProperty(global, 'Promise', desc);\n        }\n        global['Promise'] = ZoneAwarePromise;\n        var symbolThenPatched = __symbol__('thenPatched');\n        function patchThen(Ctor) {\n            var proto = Ctor.prototype;\n            var originalThen = proto.then;\n            // Keep a reference to the original method.\n            proto[symbolThen] = originalThen;\n            // check Ctor.prototype.then propertyDescritor is writable or not\n            // in meteor env, writable is false, we have to make it to be true.\n            var prop = Object.getOwnPropertyDescriptor(Ctor.prototype, 'then');\n            if (prop && prop.writable === false && prop.configurable) {\n                Object.defineProperty(Ctor.prototype, 'then', { writable: true });\n            }\n            Ctor.prototype.then = function (onResolve, onReject) {\n                var _this = this;\n                var wrapped = new ZoneAwarePromise(function (resolve, reject) {\n                    originalThen.call(_this, resolve, reject);\n                });\n                return wrapped.then(onResolve, onReject);\n            };\n            Ctor[symbolThenPatched] = true;\n        }\n        function zoneify(fn) {\n            return function () {\n                var resultPromise = fn.apply(this, arguments);\n                if (resultPromise instanceof ZoneAwarePromise) {\n                    return resultPromise;\n                }\n                var ctor = resultPromise.constructor;\n                if (!ctor[symbolThenPatched]) {\n                    patchThen(ctor);\n                }\n                return resultPromise;\n            };\n        }\n        if (NativePromise) {\n            patchThen(NativePromise);\n            var fetch_1 = global['fetch'];\n            if ((typeof fetch_1 === 'undefined' ? 'undefined' : _typeof(fetch_1)) == FUNCTION) {\n                global['fetch'] = zoneify(fetch_1);\n            }\n        }\n        // This is not part of public API, but it is useful for tests, so we expose it.\n        Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n        return ZoneAwarePromise;\n    });\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Suppress closure compiler errors about unknown 'Zone' variable\n     * @fileoverview\n     * @suppress {undefinedVars,globalThis,missingRequire}\n     */\n    var zoneSymbol = Zone.__symbol__;\n    var _global = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self || global;\n    var FUNCTION = 'function';\n    var UNDEFINED = 'undefined';\n    var REMOVE_ATTRIBUTE = 'removeAttribute';\n    var NULL_ON_PROP_VALUE = [null];\n    function bindArguments(args, source) {\n        for (var i = args.length - 1; i >= 0; i--) {\n            if (_typeof(args[i]) === FUNCTION) {\n                args[i] = Zone.current.wrap(args[i], source + '_' + i);\n            }\n        }\n        return args;\n    }\n    function wrapFunctionArgs(func, source) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            var wrappedArgs = bindArguments(args, source ? source : func.name);\n            return func.apply(this, wrappedArgs);\n        };\n    }\n    function patchArguments(target, name, source) {\n        return patchMethod(target, name, function (delegate, delegateName, name) {\n            return function (self, args) {\n                return delegate && delegate.apply(self, bindArguments(args, source));\n            };\n        });\n    }\n    function patchPrototype(prototype, fnNames) {\n        var source = prototype.constructor['name'];\n        var _loop_1 = function _loop_1(i) {\n            var name_1 = fnNames[i];\n            var delegate = prototype[name_1];\n            if (delegate) {\n                var prototypeDesc = Object.getOwnPropertyDescriptor(prototype, name_1);\n                if (!isPropertyWritable(prototypeDesc)) {\n                    return \"continue\";\n                }\n                prototype[name_1] = function (delegate) {\n                    var patched = function patched() {\n                        return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));\n                    };\n                    attachOriginToPatched(patched, delegate);\n                    return patched;\n                }(delegate);\n            }\n        };\n        for (var i = 0; i < fnNames.length; i++) {\n            _loop_1(i);\n        }\n    }\n    function isPropertyWritable(propertyDesc) {\n        if (!propertyDesc) {\n            return true;\n        }\n        if (propertyDesc.writable === false) {\n            return false;\n        }\n        if (_typeof(propertyDesc.get) === FUNCTION && _typeof(propertyDesc.set) === UNDEFINED) {\n            return false;\n        }\n        return true;\n    }\n    var isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    // Make sure to access `process` through `_global` so that WebPack does not accidently browserify\n    // this code.\n    var isNode = !('nw' in _global) && typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]';\n    var isBrowser = !isNode && !isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);\n    // we are in electron of nw, so we are both browser and nodejs\n    // Make sure to access `process` through `_global` so that WebPack does not accidently browserify\n    // this code.\n    var isMix = typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]' && !isWebWorker && !!(typeof window !== 'undefined' && window['HTMLElement']);\n    var zoneSymbolEventNames = {};\n    var wrapFn = function wrapFn(event) {\n        // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n        // event will be undefined, so we need to use window.event\n        event = event || _global.event;\n        if (!event) {\n            return;\n        }\n        var eventNameSymbol = zoneSymbolEventNames[event.type];\n        if (!eventNameSymbol) {\n            eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol('ON_PROPERTY' + event.type);\n        }\n        var target = this || event.target || _global;\n        var listener = target[eventNameSymbol];\n        var result = listener && listener.apply(this, arguments);\n        if (result != undefined && !result) {\n            event.preventDefault();\n        }\n        return result;\n    };\n    function patchProperty(obj, prop, prototype) {\n        var desc = Object.getOwnPropertyDescriptor(obj, prop);\n        if (!desc && prototype) {\n            // when patch window object, use prototype to check prop exist or not\n            var prototypeDesc = Object.getOwnPropertyDescriptor(prototype, prop);\n            if (prototypeDesc) {\n                desc = { enumerable: true, configurable: true };\n            }\n        }\n        // if the descriptor not exists or is not configurable\n        // just return\n        if (!desc || !desc.configurable) {\n            return;\n        }\n        // A property descriptor cannot have getter/setter and be writable\n        // deleting the writable and value properties avoids this error:\n        //\n        // TypeError: property descriptors must not specify a value or be writable when a\n        // getter or setter has been specified\n        delete desc.writable;\n        delete desc.value;\n        var originalDescGet = desc.get;\n        var originalDescSet = desc.set;\n        // substr(2) cuz 'onclick' -> 'click', etc\n        var eventName = prop.substr(2);\n        var eventNameSymbol = zoneSymbolEventNames[eventName];\n        if (!eventNameSymbol) {\n            eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol('ON_PROPERTY' + eventName);\n        }\n        desc.set = function (newValue) {\n            // in some of windows's onproperty callback, this is undefined\n            // so we need to check it\n            var target = this;\n            if (!target && obj === _global) {\n                target = _global;\n            }\n            if (!target) {\n                return;\n            }\n            var previousValue = target[eventNameSymbol];\n            if (previousValue) {\n                target.removeEventListener(eventName, wrapFn);\n            }\n            // issue #978, when onload handler was added before loading zone.js\n            // we should remove it with originalDescSet\n            if (originalDescSet) {\n                originalDescSet.apply(target, NULL_ON_PROP_VALUE);\n            }\n            if (typeof newValue === 'function') {\n                target[eventNameSymbol] = newValue;\n                target.addEventListener(eventName, wrapFn, false);\n            } else {\n                target[eventNameSymbol] = null;\n            }\n        };\n        // The getter would return undefined for unassigned properties but the default value of an\n        // unassigned property is null\n        desc.get = function () {\n            // in some of windows's onproperty callback, this is undefined\n            // so we need to check it\n            var target = this;\n            if (!target && obj === _global) {\n                target = _global;\n            }\n            if (!target) {\n                return null;\n            }\n            var listener = target[eventNameSymbol];\n            if (listener) {\n                return listener;\n            } else if (originalDescGet) {\n                // result will be null when use inline event attribute,\n                // such as <button onclick=\"func();\">OK</button>\n                // because the onclick function is internal raw uncompiled handler\n                // the onclick will be evaluated when first time event was triggered or\n                // the property is accessed, https://github.com/angular/zone.js/issues/525\n                // so we should use original native get to retrieve the handler\n                var value = originalDescGet && originalDescGet.apply(this);\n                if (value) {\n                    desc.set.apply(this, [value]);\n                    if (_typeof(target[REMOVE_ATTRIBUTE]) === FUNCTION) {\n                        target.removeAttribute(prop);\n                    }\n                    return value;\n                }\n            }\n            return null;\n        };\n        Object.defineProperty(obj, prop, desc);\n    }\n    function patchOnProperties(obj, properties, prototype) {\n        if (properties) {\n            for (var i = 0; i < properties.length; i++) {\n                patchProperty(obj, 'on' + properties[i], prototype);\n            }\n        } else {\n            var onProperties = [];\n            for (var prop in obj) {\n                if (prop.substr(0, 2) == 'on') {\n                    onProperties.push(prop);\n                }\n            }\n            for (var j = 0; j < onProperties.length; j++) {\n                patchProperty(obj, onProperties[j], prototype);\n            }\n        }\n    }\n    var originalInstanceKey = zoneSymbol('originalInstance');\n    // wrap some native API on `window`\n    function patchClass(className) {\n        var OriginalClass = _global[className];\n        if (!OriginalClass) return;\n        // keep original class in global\n        _global[zoneSymbol(className)] = OriginalClass;\n        _global[className] = function () {\n            var a = bindArguments(arguments, className);\n            switch (a.length) {\n                case 0:\n                    this[originalInstanceKey] = new OriginalClass();\n                    break;\n                case 1:\n                    this[originalInstanceKey] = new OriginalClass(a[0]);\n                    break;\n                case 2:\n                    this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n                    break;\n                case 3:\n                    this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n                    break;\n                case 4:\n                    this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n                    break;\n                default:\n                    throw new Error('Arg list too long.');\n            }\n        };\n        // attach original delegate to patched function\n        attachOriginToPatched(_global[className], OriginalClass);\n        var instance = new OriginalClass(function () {});\n        var prop;\n        for (prop in instance) {\n            // https://bugs.webkit.org/show_bug.cgi?id=44721\n            if (className === 'XMLHttpRequest' && prop === 'responseBlob') continue;\n            (function (prop) {\n                if (typeof instance[prop] === 'function') {\n                    _global[className].prototype[prop] = function () {\n                        return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n                    };\n                } else {\n                    Object.defineProperty(_global[className].prototype, prop, {\n                        set: function set(fn) {\n                            if (typeof fn === 'function') {\n                                this[originalInstanceKey][prop] = Zone.current.wrap(fn, className + '.' + prop);\n                                // keep callback in wrapped function so we can\n                                // use it in Function.prototype.toString to return\n                                // the native one.\n                                attachOriginToPatched(this[originalInstanceKey][prop], fn);\n                            } else {\n                                this[originalInstanceKey][prop] = fn;\n                            }\n                        },\n                        get: function get() {\n                            return this[originalInstanceKey][prop];\n                        }\n                    });\n                }\n            })(prop);\n        }\n        for (prop in OriginalClass) {\n            if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n                _global[className][prop] = OriginalClass[prop];\n            }\n        }\n    }\n    function patchMethod(target, name, patchFn) {\n        var proto = target;\n        while (proto && !proto.hasOwnProperty(name)) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        if (!proto && target[name]) {\n            // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n            proto = target;\n        }\n        var delegateName = zoneSymbol(name);\n        var delegate;\n        if (proto && !(delegate = proto[delegateName])) {\n            delegate = proto[delegateName] = proto[name];\n            // check whether proto[name] is writable\n            // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\n            var desc = proto && Object.getOwnPropertyDescriptor(proto, name);\n            if (isPropertyWritable(desc)) {\n                var patchDelegate_1 = patchFn(delegate, delegateName, name);\n                proto[name] = function () {\n                    return patchDelegate_1(this, arguments);\n                };\n                attachOriginToPatched(proto[name], delegate);\n            }\n        }\n        return delegate;\n    }\n    // TODO: @JiaLiPassion, support cancel task later if necessary\n    function patchMacroTask(obj, funcName, metaCreator) {\n        var setNative = null;\n        function scheduleTask(task) {\n            var data = task.data;\n            data.args[data.callbackIndex] = function () {\n                task.invoke.apply(this, arguments);\n            };\n            setNative.apply(data.target, data.args);\n            return task;\n        }\n        setNative = patchMethod(obj, funcName, function (delegate) {\n            return function (self, args) {\n                var meta = metaCreator(self, args);\n                if (meta.callbackIndex >= 0 && typeof args[meta.callbackIndex] === 'function') {\n                    var task = Zone.current.scheduleMacroTask(meta.name, args[meta.callbackIndex], meta, scheduleTask, null);\n                    return task;\n                } else {\n                    // cause an error by calling it directly.\n                    return delegate.apply(self, args);\n                }\n            };\n        });\n    }\n\n    function attachOriginToPatched(patched, original) {\n        patched[zoneSymbol('OriginalDelegate')] = original;\n    }\n    var isDetectedIEOrEdge = false;\n    var ieOrEdge = false;\n    function isIEOrEdge() {\n        if (isDetectedIEOrEdge) {\n            return ieOrEdge;\n        }\n        isDetectedIEOrEdge = true;\n        try {\n            var ua = window.navigator.userAgent;\n            var msie = ua.indexOf('MSIE ');\n            if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {\n                ieOrEdge = true;\n            }\n            return ieOrEdge;\n        } catch (error) {}\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // override Function.prototype.toString to make zone.js patched function\n    // look like native function\n    Zone.__load_patch('toString', function (global, Zone, api) {\n        // patch Func.prototype.toString to let them look like native\n        var originalFunctionToString = Zone['__zone_symbol__originalToString'] = Function.prototype.toString;\n        var FUNCTION = 'function';\n        var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');\n        var PROMISE_SYMBOL = zoneSymbol('Promise');\n        var ERROR_SYMBOL = zoneSymbol('Error');\n        Function.prototype.toString = function () {\n            if (_typeof(this) === FUNCTION) {\n                var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n                if (originalDelegate) {\n                    if ((typeof originalDelegate === 'undefined' ? 'undefined' : _typeof(originalDelegate)) === FUNCTION) {\n                        return originalFunctionToString.apply(this[ORIGINAL_DELEGATE_SYMBOL], arguments);\n                    } else {\n                        return Object.prototype.toString.call(originalDelegate);\n                    }\n                }\n                if (this === Promise) {\n                    var nativePromise = global[PROMISE_SYMBOL];\n                    if (nativePromise) {\n                        return originalFunctionToString.apply(nativePromise, arguments);\n                    }\n                }\n                if (this === Error) {\n                    var nativeError = global[ERROR_SYMBOL];\n                    if (nativeError) {\n                        return originalFunctionToString.apply(nativeError, arguments);\n                    }\n                }\n            }\n            return originalFunctionToString.apply(this, arguments);\n        };\n        // patch Object.prototype.toString to let them look like native\n        var originalObjectToString = Object.prototype.toString;\n        var PROMISE_OBJECT_TO_STRING = '[object Promise]';\n        Object.prototype.toString = function () {\n            if (this instanceof Promise) {\n                return PROMISE_OBJECT_TO_STRING;\n            }\n            return originalObjectToString.apply(this, arguments);\n        };\n    });\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {missingRequire}\n     */\n    var TRUE_STR = 'true';\n    var FALSE_STR = 'false';\n    // an identifier to tell ZoneTask do not create a new invoke closure\n    var OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n        isUsingGlobalCallback: true\n    };\n    var zoneSymbolEventNames$1 = {};\n    var globalSources = {};\n    var CONSTRUCTOR_NAME = 'name';\n    var FUNCTION_TYPE = 'function';\n    var OBJECT_TYPE = 'object';\n    var ZONE_SYMBOL_PREFIX = '__zone_symbol__';\n    var EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\\w+)(true|false)$/;\n    var IMMEDIATE_PROPAGATION_SYMBOL = '__zone_symbol__propagationStopped';\n    function patchEventTarget(_global, apis, patchOptions) {\n        var ADD_EVENT_LISTENER = patchOptions && patchOptions.addEventListenerFnName || 'addEventListener';\n        var REMOVE_EVENT_LISTENER = patchOptions && patchOptions.removeEventListenerFnName || 'removeEventListener';\n        var LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listenersFnName || 'eventListeners';\n        var REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.removeAllFnName || 'removeAllListeners';\n        var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n        var ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';\n        var PREPEND_EVENT_LISTENER = 'prependListener';\n        var PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';\n        var invokeTask = function invokeTask(task, target, event) {\n            // for better performance, check isRemoved which is set\n            // by removeEventListener\n            if (task.isRemoved) {\n                return;\n            }\n            var delegate = task.callback;\n            if ((typeof delegate === 'undefined' ? 'undefined' : _typeof(delegate)) === OBJECT_TYPE && delegate.handleEvent) {\n                // create the bind version of handleEvent when invoke\n                task.callback = function (event) {\n                    return delegate.handleEvent(event);\n                };\n                task.originalDelegate = delegate;\n            }\n            // invoke static task.invoke\n            task.invoke(task, target, [event]);\n            var options = task.options;\n            if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && options.once) {\n                // if options.once is true, after invoke once remove listener here\n                // only browser need to do this, nodejs eventEmitter will cal removeListener\n                // inside EventEmitter.once\n                var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;\n                target[REMOVE_EVENT_LISTENER].apply(target, [event.type, delegate_1, options]);\n            }\n        };\n        // global shared zoneAwareCallback to handle all event callback with capture = false\n        var globalZoneAwareCallback = function globalZoneAwareCallback(event) {\n            // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n            // event will be undefined, so we need to use window.event\n            event = event || _global.event;\n            if (!event) {\n                return;\n            }\n            // event.target is needed for Samusung TV and SourceBuffer\n            // || global is needed https://github.com/angular/zone.js/issues/190\n            var target = this || event.target || _global;\n            var tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];\n            if (tasks) {\n                // invoke all tasks which attached to current target with given event.type and capture = false\n                // for performance concern, if task.length === 1, just invoke\n                if (tasks.length === 1) {\n                    invokeTask(tasks[0], target, event);\n                } else {\n                    // https://github.com/angular/zone.js/issues/836\n                    // copy the tasks array before invoke, to avoid\n                    // the callback will remove itself or other listener\n                    var copyTasks = tasks.slice();\n                    for (var i = 0; i < copyTasks.length; i++) {\n                        if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n                            break;\n                        }\n                        invokeTask(copyTasks[i], target, event);\n                    }\n                }\n            }\n        };\n        // global shared zoneAwareCallback to handle all event callback with capture = true\n        var globalZoneAwareCaptureCallback = function globalZoneAwareCaptureCallback(event) {\n            // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n            // event will be undefined, so we need to use window.event\n            event = event || _global.event;\n            if (!event) {\n                return;\n            }\n            // event.target is needed for Samusung TV and SourceBuffer\n            // || global is needed https://github.com/angular/zone.js/issues/190\n            var target = this || event.target || _global;\n            var tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];\n            if (tasks) {\n                // invoke all tasks which attached to current target with given event.type and capture = false\n                // for performance concern, if task.length === 1, just invoke\n                if (tasks.length === 1) {\n                    invokeTask(tasks[0], target, event);\n                } else {\n                    // https://github.com/angular/zone.js/issues/836\n                    // copy the tasks array before invoke, to avoid\n                    // the callback will remove itself or other listener\n                    var copyTasks = tasks.slice();\n                    for (var i = 0; i < copyTasks.length; i++) {\n                        if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n                            break;\n                        }\n                        invokeTask(copyTasks[i], target, event);\n                    }\n                }\n            }\n        };\n        function patchEventTargetMethods(obj, patchOptions) {\n            if (!obj) {\n                return false;\n            }\n            var useGlobalCallback = true;\n            if (patchOptions && patchOptions.useGlobalCallback !== undefined) {\n                useGlobalCallback = patchOptions.useGlobalCallback;\n            }\n            var validateHandler = patchOptions && patchOptions.validateHandler;\n            var checkDuplicate = true;\n            if (patchOptions && patchOptions.checkDuplicate !== undefined) {\n                checkDuplicate = patchOptions.checkDuplicate;\n            }\n            var returnTarget = false;\n            if (patchOptions && patchOptions.returnTarget !== undefined) {\n                returnTarget = patchOptions.returnTarget;\n            }\n            var proto = obj;\n            while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n                proto = Object.getPrototypeOf(proto);\n            }\n            if (!proto && obj[ADD_EVENT_LISTENER]) {\n                // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n                proto = obj;\n            }\n            if (!proto) {\n                return false;\n            }\n            if (proto[zoneSymbolAddEventListener]) {\n                return false;\n            }\n            // a shared global taskData to pass data for scheduleEventTask\n            // so we do not need to create a new object just for pass some data\n            var taskData = {};\n            var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\n            var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];\n            var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];\n            var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\n            var nativePrependEventListener;\n            if (patchOptions && patchOptions.prependEventListenerFnName) {\n                nativePrependEventListener = proto[zoneSymbol(patchOptions.prependEventListenerFnName)] = proto[patchOptions.prependEventListenerFnName];\n            }\n            var customScheduleGlobal = function customScheduleGlobal(task) {\n                // if there is already a task for the eventName + capture,\n                // just return, because we use the shared globalZoneAwareCallback here.\n                if (taskData.isExisting) {\n                    return;\n                }\n                return nativeAddEventListener.apply(taskData.target, [taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options]);\n            };\n            var customCancelGlobal = function customCancelGlobal(task) {\n                // if task is not marked as isRemoved, this call is directly\n                // from Zone.prototype.cancelTask, we should remove the task\n                // from tasksList of target first\n                if (!task.isRemoved) {\n                    var symbolEventNames = zoneSymbolEventNames$1[task.eventName];\n                    var symbolEventName = void 0;\n                    if (symbolEventNames) {\n                        symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n                    }\n                    var existingTasks = symbolEventName && task.target[symbolEventName];\n                    if (existingTasks) {\n                        for (var i = 0; i < existingTasks.length; i++) {\n                            var existingTask = existingTasks[i];\n                            if (existingTask === task) {\n                                existingTasks.splice(i, 1);\n                                // set isRemoved to data for faster invokeTask check\n                                task.isRemoved = true;\n                                if (existingTasks.length === 0) {\n                                    // all tasks for the eventName + capture have gone,\n                                    // remove globalZoneAwareCallback and remove the task cache from target\n                                    task.allRemoved = true;\n                                    task.target[symbolEventName] = null;\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n                // if all tasks for the eventName + capture have gone,\n                // we will really remove the global event callback,\n                // if not, return\n                if (!task.allRemoved) {\n                    return;\n                }\n                return nativeRemoveEventListener.apply(task.target, [task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options]);\n            };\n            var customScheduleNonGlobal = function customScheduleNonGlobal(task) {\n                return nativeAddEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);\n            };\n            var customSchedulePrepend = function customSchedulePrepend(task) {\n                return nativePrependEventListener.apply(taskData.target, [taskData.eventName, task.invoke, taskData.options]);\n            };\n            var customCancelNonGlobal = function customCancelNonGlobal(task) {\n                return nativeRemoveEventListener.apply(task.target, [task.eventName, task.invoke, task.options]);\n            };\n            var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n            var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n            var compareTaskCallbackVsDelegate = function compareTaskCallbackVsDelegate(task, delegate) {\n                var typeOfDelegate = typeof delegate === 'undefined' ? 'undefined' : _typeof(delegate);\n                if (typeOfDelegate === FUNCTION_TYPE && task.callback === delegate || typeOfDelegate === OBJECT_TYPE && task.originalDelegate === delegate) {\n                    // same callback, same capture, same event name, just return\n                    return true;\n                }\n                return false;\n            };\n            var compare = patchOptions && patchOptions.compareTaskCallbackVsDelegate ? patchOptions.compareTaskCallbackVsDelegate : compareTaskCallbackVsDelegate;\n            var blackListedEvents = Zone[Zone.__symbol__('BLACK_LISTED_EVENTS')];\n            var makeAddListener = function makeAddListener(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget, prepend) {\n                if (returnTarget === void 0) {\n                    returnTarget = false;\n                }\n                if (prepend === void 0) {\n                    prepend = false;\n                }\n                return function () {\n                    var target = this || _global;\n                    var delegate = arguments[1];\n                    if (!delegate) {\n                        return nativeListener.apply(this, arguments);\n                    }\n                    // don't create the bind delegate function for handleEvent\n                    // case here to improve addEventListener performance\n                    // we will create the bind delegate when invoke\n                    var isHandleEvent = false;\n                    if ((typeof delegate === 'undefined' ? 'undefined' : _typeof(delegate)) !== FUNCTION_TYPE) {\n                        if (!delegate.handleEvent) {\n                            return nativeListener.apply(this, arguments);\n                        }\n                        isHandleEvent = true;\n                    }\n                    if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n                        return;\n                    }\n                    var eventName = arguments[0];\n                    var options = arguments[2];\n                    if (blackListedEvents) {\n                        // check black list\n                        for (var i = 0; i < blackListedEvents.length; i++) {\n                            if (eventName === blackListedEvents[i]) {\n                                return nativeListener.apply(this, arguments);\n                            }\n                        }\n                    }\n                    var capture;\n                    var once = false;\n                    if (options === undefined) {\n                        capture = false;\n                    } else if (options === true) {\n                        capture = true;\n                    } else if (options === false) {\n                        capture = false;\n                    } else {\n                        capture = options ? !!options.capture : false;\n                        once = options ? !!options.once : false;\n                    }\n                    var zone = Zone.current;\n                    var symbolEventNames = zoneSymbolEventNames$1[eventName];\n                    var symbolEventName;\n                    if (!symbolEventNames) {\n                        // the code is duplicate, but I just want to get some better performance\n                        var falseEventName = eventName + FALSE_STR;\n                        var trueEventName = eventName + TRUE_STR;\n                        var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n                        var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n                        zoneSymbolEventNames$1[eventName] = {};\n                        zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\n                        zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\n                        symbolEventName = capture ? symbolCapture : symbol;\n                    } else {\n                        symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n                    }\n                    var existingTasks = target[symbolEventName];\n                    var isExisting = false;\n                    if (existingTasks) {\n                        // already have task registered\n                        isExisting = true;\n                        if (checkDuplicate) {\n                            for (var i = 0; i < existingTasks.length; i++) {\n                                if (compare(existingTasks[i], delegate)) {\n                                    // same callback, same capture, same event name, just return\n                                    return;\n                                }\n                            }\n                        }\n                    } else {\n                        existingTasks = target[symbolEventName] = [];\n                    }\n                    var source;\n                    var constructorName = target.constructor[CONSTRUCTOR_NAME];\n                    var targetSource = globalSources[constructorName];\n                    if (targetSource) {\n                        source = targetSource[eventName];\n                    }\n                    if (!source) {\n                        source = constructorName + addSource + eventName;\n                    }\n                    // do not create a new object as task.data to pass those things\n                    // just use the global shared one\n                    taskData.options = options;\n                    if (once) {\n                        // if addEventListener with once options, we don't pass it to\n                        // native addEventListener, instead we keep the once setting\n                        // and handle ourselves.\n                        taskData.options.once = false;\n                    }\n                    taskData.target = target;\n                    taskData.capture = capture;\n                    taskData.eventName = eventName;\n                    taskData.isExisting = isExisting;\n                    var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : null;\n                    // keep taskData into data to allow onScheduleEventTask to acess the task information\n                    if (data) {\n                        data.taskData = taskData;\n                    }\n                    var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);\n                    // should clear taskData.target to avoid memory leak\n                    // issue, https://github.com/angular/angular/issues/20442\n                    taskData.target = null;\n                    // need to clear up taskData because it is a global object\n                    if (data) {\n                        data.taskData = null;\n                    }\n                    // have to save those information to task in case\n                    // application may call task.zone.cancelTask() directly\n                    if (once) {\n                        options.once = true;\n                    }\n                    task.options = options;\n                    task.target = target;\n                    task.capture = capture;\n                    task.eventName = eventName;\n                    if (isHandleEvent) {\n                        // save original delegate for compare to check duplicate\n                        task.originalDelegate = delegate;\n                    }\n                    if (!prepend) {\n                        existingTasks.push(task);\n                    } else {\n                        existingTasks.unshift(task);\n                    }\n                    if (returnTarget) {\n                        return target;\n                    }\n                };\n            };\n            proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n            if (nativePrependEventListener) {\n                proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n            }\n            proto[REMOVE_EVENT_LISTENER] = function () {\n                var target = this || _global;\n                var eventName = arguments[0];\n                var options = arguments[2];\n                var capture;\n                if (options === undefined) {\n                    capture = false;\n                } else if (options === true) {\n                    capture = true;\n                } else if (options === false) {\n                    capture = false;\n                } else {\n                    capture = options ? !!options.capture : false;\n                }\n                var delegate = arguments[1];\n                if (!delegate) {\n                    return nativeRemoveEventListener.apply(this, arguments);\n                }\n                if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n                    return;\n                }\n                var symbolEventNames = zoneSymbolEventNames$1[eventName];\n                var symbolEventName;\n                if (symbolEventNames) {\n                    symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n                }\n                var existingTasks = symbolEventName && target[symbolEventName];\n                if (existingTasks) {\n                    for (var i = 0; i < existingTasks.length; i++) {\n                        var existingTask = existingTasks[i];\n                        if (compare(existingTask, delegate)) {\n                            existingTasks.splice(i, 1);\n                            // set isRemoved to data for faster invokeTask check\n                            existingTask.isRemoved = true;\n                            if (existingTasks.length === 0) {\n                                // all tasks for the eventName + capture have gone,\n                                // remove globalZoneAwareCallback and remove the task cache from target\n                                existingTask.allRemoved = true;\n                                target[symbolEventName] = null;\n                            }\n                            existingTask.zone.cancelTask(existingTask);\n                            return;\n                        }\n                    }\n                }\n                // issue 930, didn't find the event name or callback\n                // from zone kept existingTasks, the callback maybe\n                // added outside of zone, we need to call native removeEventListener\n                // to try to remove it.\n                return nativeRemoveEventListener.apply(this, arguments);\n            };\n            proto[LISTENERS_EVENT_LISTENER] = function () {\n                var target = this || _global;\n                var eventName = arguments[0];\n                var listeners = [];\n                var tasks = findEventTasks(target, eventName);\n                for (var i = 0; i < tasks.length; i++) {\n                    var task = tasks[i];\n                    var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                    listeners.push(delegate);\n                }\n                return listeners;\n            };\n            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\n                var target = this || _global;\n                var eventName = arguments[0];\n                if (!eventName) {\n                    var keys = Object.keys(target);\n                    for (var i = 0; i < keys.length; i++) {\n                        var prop = keys[i];\n                        var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n                        var evtName = match && match[1];\n                        // in nodejs EventEmitter, removeListener event is\n                        // used for monitoring the removeListener call,\n                        // so just keep removeListener eventListener until\n                        // all other eventListeners are removed\n                        if (evtName && evtName !== 'removeListener') {\n                            this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, [evtName]);\n                        }\n                    }\n                    // remove removeListener listener finally\n                    this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].apply(this, ['removeListener']);\n                } else {\n                    var symbolEventNames = zoneSymbolEventNames$1[eventName];\n                    if (symbolEventNames) {\n                        var symbolEventName = symbolEventNames[FALSE_STR];\n                        var symbolCaptureEventName = symbolEventNames[TRUE_STR];\n                        var tasks = target[symbolEventName];\n                        var captureTasks = target[symbolCaptureEventName];\n                        if (tasks) {\n                            var removeTasks = tasks.slice();\n                            for (var i = 0; i < removeTasks.length; i++) {\n                                var task = removeTasks[i];\n                                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                                this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);\n                            }\n                        }\n                        if (captureTasks) {\n                            var removeTasks = captureTasks.slice();\n                            for (var i = 0; i < removeTasks.length; i++) {\n                                var task = removeTasks[i];\n                                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n                                this[REMOVE_EVENT_LISTENER].apply(this, [eventName, delegate, task.options]);\n                            }\n                        }\n                    }\n                }\n            };\n            // for native toString patch\n            attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n            attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n            if (nativeRemoveAllListeners) {\n                attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n            }\n            if (nativeListeners) {\n                attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n            }\n            return true;\n        }\n        var results = [];\n        for (var i = 0; i < apis.length; i++) {\n            results[i] = patchEventTargetMethods(apis[i], patchOptions);\n        }\n        return results;\n    }\n    function findEventTasks(target, eventName) {\n        var foundTasks = [];\n        for (var prop in target) {\n            var match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n            var evtName = match && match[1];\n            if (evtName && (!eventName || evtName === eventName)) {\n                var tasks = target[prop];\n                if (tasks) {\n                    for (var i = 0; i < tasks.length; i++) {\n                        foundTasks.push(tasks[i]);\n                    }\n                }\n            }\n        }\n        return foundTasks;\n    }\n    function patchEventPrototype(global, api) {\n        var Event = global['Event'];\n        if (Event && Event.prototype) {\n            api.patchMethod(Event.prototype, 'stopImmediatePropagation', function (delegate) {\n                return function (self, args) {\n                    self[IMMEDIATE_PROPAGATION_SYMBOL] = true;\n                    // we need to call the native stopImmediatePropagation\n                    // in case in some hybrid application, some part of\n                    // application will be controlled by zone, some are not\n                    delegate && delegate.apply(self, args);\n                };\n            });\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {missingRequire}\n     */\n    var taskSymbol = zoneSymbol('zoneTask');\n    function patchTimer(window, setName, cancelName, nameSuffix) {\n        var setNative = null;\n        var clearNative = null;\n        setName += nameSuffix;\n        cancelName += nameSuffix;\n        var tasksByHandleId = {};\n        var NUMBER = 'number';\n        var STRING = 'string';\n        var FUNCTION = 'function';\n        var INTERVAL = 'Interval';\n        var TIMEOUT = 'Timeout';\n        var NOT_SCHEDULED = 'notScheduled';\n        function scheduleTask(task) {\n            var data = task.data;\n            function timer() {\n                try {\n                    task.invoke.apply(this, arguments);\n                } finally {\n                    if (task.data && task.data.isPeriodic) {\n                        // issue-934, task will be cancelled\n                        // even it is a periodic task such as\n                        // setInterval\n                        return;\n                    }\n                    if (_typeof(data.handleId) === NUMBER) {\n                        // in non-nodejs env, we remove timerId\n                        // from local cache\n                        delete tasksByHandleId[data.handleId];\n                    } else if (data.handleId) {\n                        // Node returns complex objects as handleIds\n                        // we remove task reference from timer object\n                        data.handleId[taskSymbol] = null;\n                    }\n                }\n            }\n            data.args[0] = timer;\n            data.handleId = setNative.apply(window, data.args);\n            return task;\n        }\n        function clearTask(task) {\n            return clearNative(task.data.handleId);\n        }\n        setNative = patchMethod(window, setName, function (delegate) {\n            return function (self, args) {\n                if (_typeof(args[0]) === FUNCTION) {\n                    var zone = Zone.current;\n                    var options = {\n                        handleId: null,\n                        isPeriodic: nameSuffix === INTERVAL,\n                        delay: nameSuffix === TIMEOUT || nameSuffix === INTERVAL ? args[1] || 0 : null,\n                        args: args\n                    };\n                    var task = zone.scheduleMacroTask(setName, args[0], options, scheduleTask, clearTask);\n                    if (!task) {\n                        return task;\n                    }\n                    // Node.js must additionally support the ref and unref functions.\n                    var handle = task.data.handleId;\n                    if ((typeof handle === 'undefined' ? 'undefined' : _typeof(handle)) === NUMBER) {\n                        // for non nodejs env, we save handleId: task\n                        // mapping in local cache for clearTimeout\n                        tasksByHandleId[handle] = task;\n                    } else if (handle) {\n                        // for nodejs env, we save task\n                        // reference in timerId Object for clearTimeout\n                        handle[taskSymbol] = task;\n                    }\n                    // check whether handle is null, because some polyfill or browser\n                    // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\n                    if (handle && handle.ref && handle.unref && _typeof(handle.ref) === FUNCTION && _typeof(handle.unref) === FUNCTION) {\n                        task.ref = handle.ref.bind(handle);\n                        task.unref = handle.unref.bind(handle);\n                    }\n                    if ((typeof handle === 'undefined' ? 'undefined' : _typeof(handle)) === NUMBER || handle) {\n                        return handle;\n                    }\n                    return task;\n                } else {\n                    // cause an error by calling it directly.\n                    return delegate.apply(window, args);\n                }\n            };\n        });\n        clearNative = patchMethod(window, cancelName, function (delegate) {\n            return function (self, args) {\n                var id = args[0];\n                var task;\n                if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === NUMBER) {\n                    // non nodejs env.\n                    task = tasksByHandleId[id];\n                } else {\n                    // nodejs env.\n                    task = id && id[taskSymbol];\n                    // other environments.\n                    if (!task) {\n                        task = id;\n                    }\n                }\n                if (task && _typeof(task.type) === STRING) {\n                    if (task.state !== NOT_SCHEDULED && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\n                        if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === NUMBER) {\n                            delete tasksByHandleId[id];\n                        } else if (id) {\n                            id[taskSymbol] = null;\n                        }\n                        // Do not cancel already canceled functions\n                        task.zone.cancelTask(task);\n                    }\n                } else {\n                    // cause an error by calling it directly.\n                    delegate.apply(window, args);\n                }\n            };\n        });\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /*\n     * This is necessary for Chrome and Chrome mobile, to enable\n     * things like redefining `createdCallback` on an element.\n     */\n    var _defineProperty = Object[zoneSymbol('defineProperty')] = Object.defineProperty;\n    var _getOwnPropertyDescriptor = Object[zoneSymbol('getOwnPropertyDescriptor')] = Object.getOwnPropertyDescriptor;\n    var _create = Object.create;\n    var unconfigurablesKey = zoneSymbol('unconfigurables');\n    var PROTOTYPE = 'prototype';\n    var OBJECT = 'object';\n    var UNDEFINED$1 = 'undefined';\n    function propertyPatch() {\n        Object.defineProperty = function (obj, prop, desc) {\n            if (isUnconfigurable(obj, prop)) {\n                throw new TypeError('Cannot assign to read only property \\'' + prop + '\\' of ' + obj);\n            }\n            var originalConfigurableFlag = desc.configurable;\n            if (prop !== PROTOTYPE) {\n                desc = rewriteDescriptor(obj, prop, desc);\n            }\n            return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n        };\n        Object.defineProperties = function (obj, props) {\n            Object.keys(props).forEach(function (prop) {\n                Object.defineProperty(obj, prop, props[prop]);\n            });\n            return obj;\n        };\n        Object.create = function (obj, proto) {\n            if ((typeof proto === 'undefined' ? 'undefined' : _typeof(proto)) === OBJECT && !Object.isFrozen(proto)) {\n                Object.keys(proto).forEach(function (prop) {\n                    proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\n                });\n            }\n            return _create(obj, proto);\n        };\n        Object.getOwnPropertyDescriptor = function (obj, prop) {\n            var desc = _getOwnPropertyDescriptor(obj, prop);\n            if (isUnconfigurable(obj, prop)) {\n                desc.configurable = false;\n            }\n            return desc;\n        };\n    }\n    function _redefineProperty(obj, prop, desc) {\n        var originalConfigurableFlag = desc.configurable;\n        desc = rewriteDescriptor(obj, prop, desc);\n        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n    }\n    function isUnconfigurable(obj, prop) {\n        return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\n    }\n    function rewriteDescriptor(obj, prop, desc) {\n        // issue-927, if the desc is frozen, don't try to change the desc\n        if (!Object.isFrozen(desc)) {\n            desc.configurable = true;\n        }\n        if (!desc.configurable) {\n            // issue-927, if the obj is frozen, don't try to set the desc to obj\n            if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {\n                _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });\n            }\n            if (obj[unconfigurablesKey]) {\n                obj[unconfigurablesKey][prop] = true;\n            }\n        }\n        return desc;\n    }\n    function _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\n        try {\n            return _defineProperty(obj, prop, desc);\n        } catch (error) {\n            if (desc.configurable) {\n                // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's\n                // retry with the original flag value\n                if ((typeof originalConfigurableFlag === 'undefined' ? 'undefined' : _typeof(originalConfigurableFlag)) == UNDEFINED$1) {\n                    delete desc.configurable;\n                } else {\n                    desc.configurable = originalConfigurableFlag;\n                }\n                try {\n                    return _defineProperty(obj, prop, desc);\n                } catch (error) {\n                    var descJson = null;\n                    try {\n                        descJson = JSON.stringify(desc);\n                    } catch (error) {\n                        descJson = desc.toString();\n                    }\n                    console.log(\"Attempting to configure '\" + prop + \"' with descriptor '\" + descJson + \"' on object '\" + obj + \"' and got error, giving up: \" + error);\n                }\n            } else {\n                throw error;\n            }\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // we have to patch the instance since the proto is non-configurable\n    function apply(api, _global) {\n        var WS = _global.WebSocket;\n        // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener\n        // On older Chrome, no need since EventTarget was already patched\n        if (!_global.EventTarget) {\n            patchEventTarget(_global, [WS.prototype]);\n        }\n        _global.WebSocket = function (a, b) {\n            var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);\n            var proxySocket;\n            var proxySocketProto;\n            // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance\n            var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');\n            if (onmessageDesc && onmessageDesc.configurable === false) {\n                proxySocket = Object.create(socket);\n                // socket have own property descriptor 'onopen', 'onmessage', 'onclose', 'onerror'\n                // but proxySocket not, so we will keep socket as prototype and pass it to\n                // patchOnProperties method\n                proxySocketProto = socket;\n                ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function (propName) {\n                    proxySocket[propName] = function () {\n                        var args = Array.prototype.slice.call(arguments);\n                        if (propName === 'addEventListener' || propName === 'removeEventListener') {\n                            var eventName = args.length > 0 ? args[0] : undefined;\n                            if (eventName) {\n                                var propertySymbol = Zone.__symbol__('ON_PROPERTY' + eventName);\n                                socket[propertySymbol] = proxySocket[propertySymbol];\n                            }\n                        }\n                        return socket[propName].apply(socket, args);\n                    };\n                });\n            } else {\n                // we can patch the real socket\n                proxySocket = socket;\n            }\n            patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto);\n            return proxySocket;\n        };\n        var globalWebSocket = _global['WebSocket'];\n        for (var prop in WS) {\n            globalWebSocket[prop] = WS[prop];\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {globalThis}\n     */\n    var globalEventHandlersEventNames = ['abort', 'animationcancel', 'animationend', 'animationiteration', 'auxclick', 'beforeinput', 'blur', 'cancel', 'canplay', 'canplaythrough', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'cuechange', 'click', 'close', 'contextmenu', 'curechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragexit', 'dragleave', 'dragover', 'drop', 'durationchange', 'emptied', 'ended', 'error', 'focus', 'focusin', 'focusout', 'gotpointercapture', 'input', 'invalid', 'keydown', 'keypress', 'keyup', 'load', 'loadstart', 'loadeddata', 'loadedmetadata', 'lostpointercapture', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mousewheel', 'orientationchange', 'pause', 'play', 'playing', 'pointercancel', 'pointerdown', 'pointerenter', 'pointerleave', 'pointerlockchange', 'mozpointerlockchange', 'webkitpointerlockerchange', 'pointerlockerror', 'mozpointerlockerror', 'webkitpointerlockerror', 'pointermove', 'pointout', 'pointerover', 'pointerup', 'progress', 'ratechange', 'reset', 'resize', 'scroll', 'seeked', 'seeking', 'select', 'selectionchange', 'selectstart', 'show', 'sort', 'stalled', 'submit', 'suspend', 'timeupdate', 'volumechange', 'touchcancel', 'touchmove', 'touchstart', 'touchend', 'transitioncancel', 'transitionend', 'waiting', 'wheel'];\n    var documentEventNames = ['afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror', 'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange', 'visibilitychange'];\n    var windowEventNames = ['absolutedeviceorientation', 'afterinput', 'afterprint', 'appinstalled', 'beforeinstallprompt', 'beforeprint', 'beforeunload', 'devicelight', 'devicemotion', 'deviceorientation', 'deviceorientationabsolute', 'deviceproximity', 'hashchange', 'languagechange', 'message', 'mozbeforepaint', 'offline', 'online', 'paint', 'pageshow', 'pagehide', 'popstate', 'rejectionhandled', 'storage', 'unhandledrejection', 'unload', 'userproximity', 'vrdisplyconnected', 'vrdisplaydisconnected', 'vrdisplaypresentchange'];\n    var htmlElementEventNames = ['beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend', 'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend', 'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'];\n    var mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];\n    var ieElementEventNames = ['activate', 'afterupdate', 'ariarequest', 'beforeactivate', 'beforedeactivate', 'beforeeditfocus', 'beforeupdate', 'cellchange', 'controlselect', 'dataavailable', 'datasetchanged', 'datasetcomplete', 'errorupdate', 'filterchange', 'layoutcomplete', 'losecapture', 'move', 'moveend', 'movestart', 'propertychange', 'resizeend', 'resizestart', 'rowenter', 'rowexit', 'rowsdelete', 'rowsinserted', 'command', 'compassneedscalibration', 'deactivate', 'help', 'mscontentzoom', 'msmanipulationstatechanged', 'msgesturechange', 'msgesturedoubletap', 'msgestureend', 'msgesturehold', 'msgesturestart', 'msgesturetap', 'msgotpointercapture', 'msinertiastart', 'mslostpointercapture', 'mspointercancel', 'mspointerdown', 'mspointerenter', 'mspointerhover', 'mspointerleave', 'mspointermove', 'mspointerout', 'mspointerover', 'mspointerup', 'pointerout', 'mssitemodejumplistitemremoved', 'msthumbnailclick', 'stop', 'storagecommit'];\n    var webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];\n    var formEventNames = ['autocomplete', 'autocompleteerror'];\n    var detailEventNames = ['toggle'];\n    var frameEventNames = ['load'];\n    var frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll', 'messageerror'];\n    var marqueeEventNames = ['bounce', 'finish', 'start'];\n    var XMLHttpRequestEventNames = ['loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend', 'readystatechange'];\n    var IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];\n    var websocketEventNames = ['close', 'error', 'open', 'message'];\n    var workerEventNames = ['error', 'message'];\n    var eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);\n    function filterProperties(target, onProperties, ignoreProperties) {\n        if (!ignoreProperties) {\n            return onProperties;\n        }\n        var tip = ignoreProperties.filter(function (ip) {\n            return ip.target === target;\n        });\n        if (!tip || tip.length === 0) {\n            return onProperties;\n        }\n        var targetIgnoreProperties = tip[0].ignoreProperties;\n        return onProperties.filter(function (op) {\n            return targetIgnoreProperties.indexOf(op) === -1;\n        });\n    }\n    function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n        var filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n        patchOnProperties(target, filteredProperties, prototype);\n    }\n    function propertyDescriptorPatch(api, _global) {\n        if (isNode && !isMix) {\n            return;\n        }\n        var supportsWebSocket = typeof WebSocket !== 'undefined';\n        if (canPatchViaPropertyDescriptor()) {\n            var ignoreProperties = _global.__Zone_ignore_on_properties;\n            // for browsers that we can patch the descriptor:  Chrome & Firefox\n            if (isBrowser) {\n                // in IE/Edge, onProp not exist in window object, but in WindowPrototype\n                // so we need to pass WindowPrototype to check onProp exist or not\n                patchFilteredProperties(window, eventNames.concat(['messageerror']), ignoreProperties, Object.getPrototypeOf(window));\n                patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);\n                if (typeof window['SVGElement'] !== 'undefined') {\n                    patchFilteredProperties(window['SVGElement'].prototype, eventNames, ignoreProperties);\n                }\n                patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);\n                patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);\n                patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);\n                patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\n                patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);\n                patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);\n                patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);\n                var HTMLMarqueeElement_1 = window['HTMLMarqueeElement'];\n                if (HTMLMarqueeElement_1) {\n                    patchFilteredProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames, ignoreProperties);\n                }\n                var Worker_1 = window['Worker'];\n                if (Worker_1) {\n                    patchFilteredProperties(Worker_1.prototype, workerEventNames, ignoreProperties);\n                }\n            }\n            patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);\n            var XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];\n            if (XMLHttpRequestEventTarget) {\n                patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);\n            }\n            if (typeof IDBIndex !== 'undefined') {\n                patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);\n                patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\n                patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);\n                patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);\n                patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);\n                patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);\n            }\n            if (supportsWebSocket) {\n                patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);\n            }\n        } else {\n            // Safari, Android browsers (Jelly Bean)\n            patchViaCapturingAllTheEvents();\n            patchClass('XMLHttpRequest');\n            if (supportsWebSocket) {\n                apply(api, _global);\n            }\n        }\n    }\n    function canPatchViaPropertyDescriptor() {\n        if ((isBrowser || isMix) && !Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {\n            // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\n            // IDL interface attributes are not configurable\n            var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');\n            if (desc && !desc.configurable) return false;\n        }\n        var xhrDesc = Object.getOwnPropertyDescriptor(XMLHttpRequest.prototype, 'onreadystatechange');\n        // add enumerable and configurable here because in opera\n        // by default XMLHttpRequest.prototype.onreadystatechange is undefined\n        // without adding enumerable and configurable will cause onreadystatechange\n        // non-configurable\n        // and if XMLHttpRequest.prototype.onreadystatechange is undefined,\n        // we should set a real desc instead a fake one\n        if (xhrDesc) {\n            Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {\n                enumerable: true,\n                configurable: true,\n                get: function get() {\n                    return true;\n                }\n            });\n            var req = new XMLHttpRequest();\n            var result = !!req.onreadystatechange;\n            // restore original desc\n            Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', xhrDesc || {});\n            return result;\n        } else {\n            var SYMBOL_FAKE_ONREADYSTATECHANGE_1 = zoneSymbol('fakeonreadystatechange');\n            Object.defineProperty(XMLHttpRequest.prototype, 'onreadystatechange', {\n                enumerable: true,\n                configurable: true,\n                get: function get() {\n                    return this[SYMBOL_FAKE_ONREADYSTATECHANGE_1];\n                },\n                set: function set(value) {\n                    this[SYMBOL_FAKE_ONREADYSTATECHANGE_1] = value;\n                }\n            });\n            var req = new XMLHttpRequest();\n            var detectFunc = function detectFunc() {};\n            req.onreadystatechange = detectFunc;\n            var result = req[SYMBOL_FAKE_ONREADYSTATECHANGE_1] === detectFunc;\n            req.onreadystatechange = null;\n            return result;\n        }\n    }\n    var unboundKey = zoneSymbol('unbound');\n    // Whenever any eventListener fires, we check the eventListener target and all parents\n    // for `onwhatever` properties and replace them with zone-bound functions\n    // - Chrome (for now)\n    function patchViaCapturingAllTheEvents() {\n        var _loop_1 = function _loop_1(i) {\n            var property = eventNames[i];\n            var onproperty = 'on' + property;\n            self.addEventListener(property, function (event) {\n                var elt = event.target,\n                    bound,\n                    source;\n                if (elt) {\n                    source = elt.constructor['name'] + '.' + onproperty;\n                } else {\n                    source = 'unknown.' + onproperty;\n                }\n                while (elt) {\n                    if (elt[onproperty] && !elt[onproperty][unboundKey]) {\n                        bound = Zone.current.wrap(elt[onproperty], source);\n                        bound[unboundKey] = elt[onproperty];\n                        elt[onproperty] = bound;\n                    }\n                    elt = elt.parentElement;\n                }\n            }, true);\n        };\n        for (var i = 0; i < eventNames.length; i++) {\n            _loop_1(i);\n        }\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function eventTargetPatch(_global, api) {\n        var WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';\n        var NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'.split(',');\n        var EVENT_TARGET = 'EventTarget';\n        var apis = [];\n        var isWtf = _global['wtf'];\n        var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(',');\n        if (isWtf) {\n            // Workaround for: https://github.com/google/tracing-framework/issues/555\n            apis = WTF_ISSUE_555_ARRAY.map(function (v) {\n                return 'HTML' + v + 'Element';\n            }).concat(NO_EVENT_TARGET);\n        } else if (_global[EVENT_TARGET]) {\n            apis.push(EVENT_TARGET);\n        } else {\n            // Note: EventTarget is not available in all browsers,\n            // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget\n            apis = NO_EVENT_TARGET;\n        }\n        var isDisableIECheck = _global['__Zone_disable_IE_check'] || false;\n        var isEnableCrossContextCheck = _global['__Zone_enable_cross_context_check'] || false;\n        var ieOrEdge = isIEOrEdge();\n        var ADD_EVENT_LISTENER_SOURCE = '.addEventListener:';\n        var FUNCTION_WRAPPER = '[object FunctionWrapper]';\n        var BROWSER_TOOLS = 'function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }';\n        //  predefine all __zone_symbol__ + eventName + true/false string\n        for (var i = 0; i < eventNames.length; i++) {\n            var eventName = eventNames[i];\n            var falseEventName = eventName + FALSE_STR;\n            var trueEventName = eventName + TRUE_STR;\n            var symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n            var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n            zoneSymbolEventNames$1[eventName] = {};\n            zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;\n            zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;\n        }\n        //  predefine all task.source string\n        for (var i = 0; i < WTF_ISSUE_555.length; i++) {\n            var target = WTF_ISSUE_555_ARRAY[i];\n            var targets = globalSources[target] = {};\n            for (var j = 0; j < eventNames.length; j++) {\n                var eventName = eventNames[j];\n                targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;\n            }\n        }\n        var checkIEAndCrossContext = function checkIEAndCrossContext(nativeDelegate, delegate, target, args) {\n            if (!isDisableIECheck && ieOrEdge) {\n                if (isEnableCrossContextCheck) {\n                    try {\n                        var testString = delegate.toString();\n                        if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {\n                            nativeDelegate.apply(target, args);\n                            return false;\n                        }\n                    } catch (error) {\n                        nativeDelegate.apply(target, args);\n                        return false;\n                    }\n                } else {\n                    var testString = delegate.toString();\n                    if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {\n                        nativeDelegate.apply(target, args);\n                        return false;\n                    }\n                }\n            } else if (isEnableCrossContextCheck) {\n                try {\n                    delegate.toString();\n                } catch (error) {\n                    nativeDelegate.apply(target, args);\n                    return false;\n                }\n            }\n            return true;\n        };\n        var apiTypes = [];\n        for (var i = 0; i < apis.length; i++) {\n            var type = _global[apis[i]];\n            apiTypes.push(type && type.prototype);\n        }\n        patchEventTarget(_global, apiTypes, { validateHandler: checkIEAndCrossContext });\n        api.patchEventTarget = patchEventTarget;\n        return true;\n    }\n    function patchEvent(global, api) {\n        patchEventPrototype(global, api);\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function registerElementPatch(_global) {\n        if (!isBrowser && !isMix || !('registerElement' in _global.document)) {\n            return;\n        }\n        var _registerElement = document.registerElement;\n        var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];\n        document.registerElement = function (name, opts) {\n            if (opts && opts.prototype) {\n                callbacks.forEach(function (callback) {\n                    var source = 'Document.registerElement::' + callback;\n                    if (opts.prototype.hasOwnProperty(callback)) {\n                        var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);\n                        if (descriptor && descriptor.value) {\n                            descriptor.value = Zone.current.wrap(descriptor.value, source);\n                            _redefineProperty(opts.prototype, callback, descriptor);\n                        } else {\n                            opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n                        }\n                    } else if (opts.prototype[callback]) {\n                        opts.prototype[callback] = Zone.current.wrap(opts.prototype[callback], source);\n                    }\n                });\n            }\n            return _registerElement.apply(document, [name, opts]);\n        };\n        attachOriginToPatched(document.registerElement, _registerElement);\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * @fileoverview\n     * @suppress {missingRequire}\n     */\n    Zone.__load_patch('util', function (global, Zone, api) {\n        api.patchOnProperties = patchOnProperties;\n        api.patchMethod = patchMethod;\n        api.patchArguments = patchArguments;\n    });\n    Zone.__load_patch('timers', function (global, Zone, api) {\n        var set = 'set';\n        var clear = 'clear';\n        patchTimer(global, set, clear, 'Timeout');\n        patchTimer(global, set, clear, 'Interval');\n        patchTimer(global, set, clear, 'Immediate');\n    });\n    Zone.__load_patch('requestAnimationFrame', function (global, Zone, api) {\n        patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n        patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n        patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n    });\n    Zone.__load_patch('blocking', function (global, Zone, api) {\n        var blockingMethods = ['alert', 'prompt', 'confirm'];\n        for (var i = 0; i < blockingMethods.length; i++) {\n            var name_1 = blockingMethods[i];\n            patchMethod(global, name_1, function (delegate, symbol, name) {\n                return function (s, args) {\n                    return Zone.current.run(delegate, global, args, name);\n                };\n            });\n        }\n    });\n    Zone.__load_patch('EventTarget', function (global, Zone, api) {\n        // load blackListEvents from global\n        var SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');\n        if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\n            Zone[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];\n        }\n        patchEvent(global, api);\n        eventTargetPatch(global, api);\n        // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n        var XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n        if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n            api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);\n        }\n        patchClass('MutationObserver');\n        patchClass('WebKitMutationObserver');\n        patchClass('IntersectionObserver');\n        patchClass('FileReader');\n    });\n    Zone.__load_patch('on_property', function (global, Zone, api) {\n        propertyDescriptorPatch(api, global);\n        propertyPatch();\n        registerElementPatch(global);\n    });\n    Zone.__load_patch('canvas', function (global, Zone, api) {\n        var HTMLCanvasElement = global['HTMLCanvasElement'];\n        if (typeof HTMLCanvasElement !== 'undefined' && HTMLCanvasElement.prototype && HTMLCanvasElement.prototype.toBlob) {\n            patchMacroTask(HTMLCanvasElement.prototype, 'toBlob', function (self, args) {\n                return { name: 'HTMLCanvasElement.toBlob', target: self, callbackIndex: 0, args: args };\n            });\n        }\n    });\n    Zone.__load_patch('XHR', function (global, Zone, api) {\n        // Treat XMLHTTPRequest as a macrotask.\n        patchXHR(global);\n        var XHR_TASK = zoneSymbol('xhrTask');\n        var XHR_SYNC = zoneSymbol('xhrSync');\n        var XHR_LISTENER = zoneSymbol('xhrListener');\n        var XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n        var XHR_URL = zoneSymbol('xhrURL');\n        function patchXHR(window) {\n            function findPendingTask(target) {\n                var pendingTask = target[XHR_TASK];\n                return pendingTask;\n            }\n            var SYMBOL_ADDEVENTLISTENER = zoneSymbol('addEventListener');\n            var SYMBOL_REMOVEEVENTLISTENER = zoneSymbol('removeEventListener');\n            var oriAddListener = XMLHttpRequest.prototype[SYMBOL_ADDEVENTLISTENER];\n            var oriRemoveListener = XMLHttpRequest.prototype[SYMBOL_REMOVEEVENTLISTENER];\n            if (!oriAddListener) {\n                var XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];\n                if (XMLHttpRequestEventTarget) {\n                    oriAddListener = XMLHttpRequestEventTarget.prototype[SYMBOL_ADDEVENTLISTENER];\n                    oriRemoveListener = XMLHttpRequestEventTarget.prototype[SYMBOL_REMOVEEVENTLISTENER];\n                }\n            }\n            var READY_STATE_CHANGE = 'readystatechange';\n            var SCHEDULED = 'scheduled';\n            function scheduleTask(task) {\n                XMLHttpRequest[XHR_SCHEDULED] = false;\n                var data = task.data;\n                var target = data.target;\n                // remove existing event listener\n                var listener = target[XHR_LISTENER];\n                if (!oriAddListener) {\n                    oriAddListener = target[SYMBOL_ADDEVENTLISTENER];\n                    oriRemoveListener = target[SYMBOL_REMOVEEVENTLISTENER];\n                }\n                if (listener) {\n                    oriRemoveListener.apply(target, [READY_STATE_CHANGE, listener]);\n                }\n                var newListener = target[XHR_LISTENER] = function () {\n                    if (target.readyState === target.DONE) {\n                        // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n                        // readyState=4 multiple times, so we need to check task state here\n                        if (!data.aborted && XMLHttpRequest[XHR_SCHEDULED] && task.state === SCHEDULED) {\n                            task.invoke();\n                        }\n                    }\n                };\n                oriAddListener.apply(target, [READY_STATE_CHANGE, newListener]);\n                var storedTask = target[XHR_TASK];\n                if (!storedTask) {\n                    target[XHR_TASK] = task;\n                }\n                sendNative.apply(target, data.args);\n                XMLHttpRequest[XHR_SCHEDULED] = true;\n                return task;\n            }\n            function placeholderCallback() {}\n            function clearTask(task) {\n                var data = task.data;\n                // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n                // to prevent it from firing. So instead, we store info for the event listener.\n                data.aborted = true;\n                return abortNative.apply(data.target, data.args);\n            }\n            var openNative = patchMethod(window.XMLHttpRequest.prototype, 'open', function () {\n                return function (self, args) {\n                    self[XHR_SYNC] = args[2] == false;\n                    self[XHR_URL] = args[1];\n                    return openNative.apply(self, args);\n                };\n            });\n            var XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';\n            var sendNative = patchMethod(window.XMLHttpRequest.prototype, 'send', function () {\n                return function (self, args) {\n                    var zone = Zone.current;\n                    if (self[XHR_SYNC]) {\n                        // if the XHR is sync there is no task to schedule, just execute the code.\n                        return sendNative.apply(self, args);\n                    } else {\n                        var options = {\n                            target: self,\n                            url: self[XHR_URL],\n                            isPeriodic: false,\n                            delay: null,\n                            args: args,\n                            aborted: false\n                        };\n                        return zone.scheduleMacroTask(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n                    }\n                };\n            });\n            var STRING_TYPE = 'string';\n            var abortNative = patchMethod(window.XMLHttpRequest.prototype, 'abort', function (delegate) {\n                return function (self, args) {\n                    var task = findPendingTask(self);\n                    if (task && _typeof(task.type) == STRING_TYPE) {\n                        // If the XHR has already completed, do nothing.\n                        // If the XHR has already been aborted, do nothing.\n                        // Fix #569, call abort multiple times before done will cause\n                        // macroTask task count be negative number\n                        if (task.cancelFn == null || task.data && task.data.aborted) {\n                            return;\n                        }\n                        task.zone.cancelTask(task);\n                    }\n                    // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n                    // task\n                    // to cancel. Do nothing.\n                };\n            });\n        }\n    });\n    Zone.__load_patch('geolocation', function (global, Zone, api) {\n        /// GEO_LOCATION\n        if (global['navigator'] && global['navigator'].geolocation) {\n            patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n        }\n    });\n    Zone.__load_patch('getUserMedia', function (global, Zone, api) {\n        var navigator = global['navigator'];\n        if (navigator && navigator.getUserMedia) {\n            navigator.getUserMedia = wrapFunctionArgs(navigator.getUserMedia);\n        }\n    });\n    Zone.__load_patch('PromiseRejectionEvent', function (global, Zone, api) {\n        // handle unhandled promise rejection\n        function findPromiseRejectionHandler(evtName) {\n            return function (e) {\n                var eventTasks = findEventTasks(global, evtName);\n                eventTasks.forEach(function (eventTask) {\n                    // windows has added unhandledrejection event listener\n                    // trigger the event listener\n                    var PromiseRejectionEvent = global['PromiseRejectionEvent'];\n                    if (PromiseRejectionEvent) {\n                        var evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });\n                        eventTask.invoke(evt);\n                    }\n                });\n            };\n        }\n        if (global['PromiseRejectionEvent']) {\n            Zone[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');\n            Zone[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');\n        }\n    });\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ApmBase = function () {\n  function ApmBase(serviceFactory, disable) {\n    _classCallCheck(this, ApmBase);\n\n    this._disable = disable;\n    this.serviceFactory = serviceFactory;\n  }\n\n  _createClass(ApmBase, [{\n    key: 'init',\n    value: function init(config) {\n      if (this.isEnabled()) {\n        var configService = this.serviceFactory.getService('ConfigService');\n        configService.setConfig({\n          agentName: 'js-base',\n          agentVersion: '0.3.0'\n        });\n        configService.setConfig(config);\n        this.serviceFactory.init();\n        var errorLogging = this.serviceFactory.getService('ErrorLogging');\n        errorLogging.registerGlobalEventListener();\n\n        var performanceMonitoring = this.serviceFactory.getService('PerformanceMonitoring');\n        performanceMonitoring.init();\n\n        var transactionService = this.serviceFactory.getService('TransactionService');\n        window.addEventListener('load', function (event) {\n          // to make sure PerformanceTiming.loadEventEnd has a value\n          setTimeout(function () {\n            // need to delegate sending navigation timing to the router liberay\n            if (!configService.get('hasRouterLibrary')) {\n              transactionService.sendPageLoadMetrics();\n            }\n          });\n        });\n      }\n      return this;\n    }\n  }, {\n    key: 'isEnabled',\n    value: function isEnabled() {\n      return !this._disable;\n    }\n  }, {\n    key: 'config',\n    value: function config(_config) {\n      var configService = this.serviceFactory.getService('ConfigService');\n      configService.setConfig(_config);\n    }\n  }, {\n    key: 'setUserContext',\n    value: function setUserContext(userContext) {\n      var configService = this.serviceFactory.getService('ConfigService');\n      configService.setUserContext(userContext);\n    }\n  }, {\n    key: 'setCustomContext',\n    value: function setCustomContext(customContext) {\n      var configService = this.serviceFactory.getService('ConfigService');\n      configService.setCustomContext(customContext);\n    }\n  }, {\n    key: 'setTag',\n    value: function setTag(key, value) {\n      var configService = this.serviceFactory.getService('ConfigService');\n      configService.setTag(key, value);\n    }\n\n    // Should call this method before 'load' event on window is fired\n\n  }, {\n    key: 'setInitialPageLoadName',\n    value: function setInitialPageLoadName(name) {\n      if (this.isEnabled()) {\n        var transactionService = this.serviceFactory.getService('TransactionService');\n        transactionService.initialPageLoadName = name;\n      }\n    }\n  }, {\n    key: 'captureError',\n    value: function captureError(error) {\n      if (this.isEnabled()) {\n        var errorLogging = this.serviceFactory.getService('ErrorLogging');\n        return errorLogging.logError(error);\n      }\n    }\n  }]);\n\n  return ApmBase;\n}();\n\nmodule.exports = ApmBase;\n\n/***/ })\n/******/ ]);\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./dist/bundles/elastic-apm-js-base.umd.js\n// module id = 0\n// module chunks = 0",
    "var initElasticApm = require('../../..').init\n// import init as initElasticApm from '../../..'\nvar createApmBase = require('../e2e')\nvar elasticApm = createApmBase({\n  debug: true,\n  serverUrl: 'http://localhost:8200',\n  serviceName: 'apm-agent-js-base-test-e2e-general-usecase',\n  serviceVersion: '0.0.1'\n})\n\nelasticApm.setInitialPageLoadName('general-usecase-initial-page-load')\n\nelasticApm.setUserContext({usertest: 'usertest',id: 'userId',username: 'username',email: 'email'})\nelasticApm.setCustomContext({testContext: 'testContext'})\nelasticApm.setTag('testTagKey', 'testTagValue')\n\nfunction generateError () {\n  throw new Error('timeout test error')\n}\n\nsetTimeout(function () {\n  generateError()\n}, 100)\n\ngenerateError.tmp = 'tmp'\n\nvar appEl = document.getElementById('app')\nvar testEl = document.createElement('h2')\ntestEl.setAttribute('id', 'test-element')\ntestEl.innerHTML = 'Passed'\nappEl.appendChild(testEl)\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./test/e2e/general-usecase/app.js\n// module id = 1\n// module chunks = 0",
    "var initElasticApm = require('../..').init\nvar apmBase = require('../..').apmBase\nvar ApmServerMock = require('elastic-apm-js-core/test/utils/apm-server-mock.js')\nfunction createApmBase (config) {\n  // config.serverUrl = 'http://localhost:8200'\n  var gc = globalConfigs || {}\n  console.log(gc)\n  var apmServer\n  if (!gc.useMocks) {\n    apmServer = apmBase.serviceFactory.getService('ApmServer')\n  }\n  if (gc.serverUrl) {\n    config.serverUrl = gc.serverUrl\n  }\n  var serverMock = new ApmServerMock(apmServer)\n  apmBase.serviceFactory.registerServiceInstance('ApmServer', serverMock)\n\n  elasticApm = initElasticApm(config)\n  return elasticApm\n}\n\nmodule.exports = createApmBase\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./test/e2e/e2e.js\n// module id = 2\n// module chunks = 0",
    "var Subscription = require('../../src/common/subscription')\nclass ApmServerMock {\n  constructor (apmServer) {\n    var subscription = this.subscription = new Subscription()\n    var _apmServer = this._apmServer = apmServer\n    var calls = this.calls = {}\n\n    function captureCall (methodName, call) {\n      if (calls[methodName]) {\n        calls[methodName].push(call)\n      }else {\n        calls[methodName] = [call]\n      }\n      subscription.applyAll(this, [call])\n    }\n    function applyMock (methodName, captureFn) {\n      var args = Array.prototype.slice.call(arguments)\n      args.splice(0, 2)\n      var result\n      var mocked = false\n      if (_apmServer) {\n        result = _apmServer[methodName].apply(_apmServer, args)\n      }else {\n        result = Promise.resolve()\n        mocked = true\n      }\n      var call = {args: args, mocked: mocked}\n      captureFn(methodName, call)\n      return result\n    }\n\n    function spyOn (service, methodName) {\n      var _orig = service[methodName]\n      return service[methodName] = function () {\n        var args = Array.prototype.slice.call(arguments)\n        var call = {args: args,mocked: false}\n        captureCall(methodName, call)\n        return _orig.apply(service, arguments)\n      }\n    }\n\n    this.sendErrors = _apmServer ?\n      spyOn(_apmServer, 'sendErrors') :\n      applyMock.bind(_apmServer, 'sendErrors', captureCall)\n    this.sendTransactions = _apmServer ?\n      spyOn(_apmServer, 'sendTransactions') :\n      applyMock.bind(_apmServer, 'sendTransactions', captureCall)\n\n    this.addError = applyMock.bind(_apmServer, 'addError', captureCall)\n    this.addTransaction = applyMock.bind(_apmServer, 'addTransaction', captureCall)\n  }\n  init () {}\n}\n\nmodule.exports = ApmServerMock\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../apm-agent-js-core/test/utils/apm-server-mock.js\n// module id = 3\n// module chunks = 0",
    "function Subscription () {\n  this.subscriptions = []\n}\n\nSubscription.prototype.subscribe = function (fn) {\n  var self = this\n  this.subscriptions.push(fn)\n\n  return function () {\n    var index = self.subscriptions.indexOf(fn)\n    if (index > -1) {\n      self.subscriptions.splice(index, 1)\n    }\n  }\n}\n\nSubscription.prototype.applyAll = function (applyTo, applyWith) {\n  this.subscriptions.forEach(function (fn) {\n    try {\n      fn.apply(applyTo, applyWith)\n    } catch (error) {\n      console.log(error, error.stack)\n    }\n  }, this)\n}\n\nmodule.exports = Subscription\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../apm-agent-js-core/src/common/subscription.js\n// module id = 4\n// module chunks = 0"
  ],
  "sourceRoot": ""
}